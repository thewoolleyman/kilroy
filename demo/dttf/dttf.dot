digraph dttf_pipeline {
    graph [
        goal="a Go-based TrueType font generation tool (DTTF) that converts bitmap glyph PNGs to valid .ttf files, including custom quadratic Bezier tracer, font table assembly, quality metrics (SSIM), round-trip test harness, CLI + library API, and comprehensive documentation",
        rankdir=LR,
        default_max_retry=3,
        retry_target="implement",
        fallback_retry_target="debate_consolidate",
        provenance_version="1",
        model_stylesheet="
            * { llm_model: minimax-m2.5; llm_provider: minimax; }
            .hard { llm_model: minimax-m2.5; llm_provider: minimax; }
            .verify { llm_model: minimax-m2.5; llm_provider: minimax; }
            .branch-a { llm_model: minimax-m2.5; llm_provider: minimax; }
            .branch-b { llm_model: moonshotai/kimi-k2.5; llm_provider: kimi; }
            .branch-c { llm_model: glm-5; llm_provider: zai; }
        "
    ]

    start [shape=Mdiamond, label="Start"]
    exit  [shape=Msquare, label="Exit"]

    // =========================================================================
    // Bootstrap: Toolchain + Spec
    // =========================================================================

    check_toolchain [
        shape=parallelogram,
        max_retries=0,
        tool_command="command -v go >/dev/null 2>&1 || { echo 'ERROR: Go toolchain not found. Install Go 1.21+ from https://go.dev/dl/' >&2; exit 1; }; go version | grep -qE 'go1\\.(2[1-9]|[3-9][0-9])' || { echo 'ERROR: Go 1.21+ required' >&2; exit 1; }; echo 'Go toolchain verified'"
    ]

    expand_spec [
        shape=box,
        auto_status=true,
        prompt="Goal: $goal\n\nBootstrap the canonical spec file at .ai/spec.md.\n\nThe authoritative source specification is: demo/dttf/dttf-v1.md\n\nStep 1 (reuse existing): If .ai/spec.md already exists and is a complete spec (not a placeholder), keep its meaning. You may do form-only cleanup (headings/whitespace) if needed.\n\nStep 2 (reuse repo spec): Since demo/dttf/dttf-v1.md is the authoritative specification:\n- Read demo/dttf/dttf-v1.md in full\n- Copy it VERBATIM to .ai/spec.md (the downstream canonical path)\n- This is not a summary or rewrite — it is a byte-for-byte preservation of the source spec\n- The only changes allowed are formatting adjustments needed for markdown rendering (e.g., escaping special characters)\n\nStep 3 (if no spec exists): This step should not be needed since demo/dttf/dttf-v1.md exists.\n\nVerify: After writing .ai/spec.md, confirm it contains all 12 sections from the source (Input, Output, Tracer, Architecture, Quality Function, Test Harness, Data Structures, File Assembly, Error Handling, Dependencies, Rasterizer, CLI Reference).\n\nWrite to .ai/spec.md."
    ]

    check_dod [
        shape=box,
        label="DoD exists?",
        prompt="Goal: $goal\n\nCheck whether .ai/definition_of_done.md exists AND is a real project Definition of Done (not a placeholder).\n\nDoD rubric (must be specific, verifiable, and not over-prescriptive):\n- Scope: defines what is in-scope and what is out-of-scope.\n- Deliverables: names concrete outputs/outcomes (artifacts, behaviors, docs), not implementation steps.\n- Acceptance criteria: includes observable pass/fail criteria a reviewer can verify.\n- Verification: includes how to verify (commands or steps) appropriate for the project, without forcing a particular tool unless required.\n- Quality/safety: includes project-appropriate quality expectations stated as outcomes/evidence.\n- Non-goals/deferrals: explicitly calls out what is intentionally not being done in this iteration.\n\nCoverage checklist: the DoD must explicitly address each item (either include criteria, or mark N/A with a short reason):\n- Build/package/install correctness (go build, go install)\n- Automated tests (go test)\n- Lint/format/static analysis (gofmt, go vet)\n- Documentation/user guidance (godoc, README, CLI help)\n- Compatibility/breaking changes/migrations (Go version requirements)\n- Security/privacy considerations (file I/O safety, error handling)\n- Operational readiness when relevant (logging, error messages, exit codes)\n- Performance/reliability when relevant (SSIM thresholds, tracer performance)\n\nClassify:\n- Set `status` to `has_dod` if the file meets the rubric AND covers the checklist.\n- Set `status` to `needs_dod` otherwise.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\nUse canonical schema: {\"status\":\"...\"}\n\nNote: routing edges use condition=\"outcome=<status>\" (outcome mirrors the status.json `status` value)."
    ]

    // =========================================================================
    // DoD Fanout
    // =========================================================================

    dod_fanout [shape=component, label="DoD Fan-Out"]

    dod_a [
        class="branch-a",
        prompt="Goal: $goal\n\nPropose a project Definition of Done (DoD) for DTTF.\nRead .ai/spec.md (the complete DTTF v1 specification).\n\nRequirements:\n- DoD must be a checklist of outcomes/evidence, not a plan.\n- Each item must be verifiable (someone can check it and say pass/fail).\n- Avoid prescribing the implementation approach unless the spec explicitly requires it.\n- Include scope, deliverables, acceptance criteria, verification approach, and explicit non-goals/deferrals.\n- Keep it general enough for the project type while still preventing obvious 'done-but-not-really' loopholes.\n\nCoverage checklist: explicitly address each item (include criteria, or mark N/A with a short reason):\n- Build/package/install correctness (go build succeeds, go install works, binary runs)\n- Automated tests (go test passes for all packages, test coverage for core pipeline stages)\n- Lint/format/static analysis (gofmt check passes, go vet passes)\n- Documentation/user guidance (godoc comments on public API, README with usage examples, CLI --help output)\n- Compatibility/breaking changes/migrations (Go 1.21+ requirement documented)\n- Security/privacy considerations (safe file I/O, proper error handling, no arbitrary file write vulnerabilities)\n- Operational readiness (clear error messages, appropriate exit codes, verbose/debug flags)\n- Performance/reliability (SSIM thresholds documented, tracer handles 1000-point glyphs, round-trip tests pass)\n\nWrite to .ai/dod_a.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\nUse canonical schema: {\"status\":\"success\"}"
    ]

    dod_b [
        class="branch-b",
        prompt="Goal: $goal\n\nPropose a project Definition of Done (DoD) for DTTF.\nRead .ai/spec.md (the complete DTTF v1 specification).\n\nRequirements:\n- DoD must be a checklist of outcomes/evidence, not a plan.\n- Each item must be verifiable (someone can check it and say pass/fail).\n- Avoid prescribing the implementation approach unless the spec explicitly requires it.\n- Include scope, deliverables, acceptance criteria, verification approach, and explicit non-goals/deferrals.\n- Keep it general enough for the project type while still preventing obvious 'done-but-not-really' loopholes.\n\nCoverage checklist: explicitly address each item (include criteria, or mark N/A with a short reason):\n- Build/package/install correctness (go build succeeds, go install works, binary runs)\n- Automated tests (go test passes for all packages, test coverage for core pipeline stages)\n- Lint/format/static analysis (gofmt check passes, go vet passes)\n- Documentation/user guidance (godoc comments on public API, README with usage examples, CLI --help output)\n- Compatibility/breaking changes/migrations (Go 1.21+ requirement documented)\n- Security/privacy considerations (safe file I/O, proper error handling, no arbitrary file write vulnerabilities)\n- Operational readiness (clear error messages, appropriate exit codes, verbose/debug flags)\n- Performance/reliability (SSIM thresholds documented, tracer handles 1000-point glyphs, round-trip tests pass)\n\nWrite to .ai/dod_b.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\nUse canonical schema: {\"status\":\"success\"}"
    ]

    dod_c [
        class="branch-c",
        prompt="Goal: $goal\n\nPropose a project Definition of Done (DoD) for DTTF.\nRead .ai/spec.md (the complete DTTF v1 specification).\n\nRequirements:\n- DoD must be a checklist of outcomes/evidence, not a plan.\n- Each item must be verifiable (someone can check it and say pass/fail).\n- Avoid prescribing the implementation approach unless the spec explicitly requires it.\n- Include scope, deliverables, acceptance criteria, verification approach, and explicit non-goals/deferrals.\n- Keep it general enough for the project type while still preventing obvious 'done-but-not-really' loopholes.\n\nCoverage checklist: explicitly address each item (include criteria, or mark N/A with a short reason):\n- Build/package/install correctness (go build succeeds, go install works, binary runs)\n- Automated tests (go test passes for all packages, test coverage for core pipeline stages)\n- Lint/format/static analysis (gofmt check passes, go vet passes)\n- Documentation/user guidance (godoc comments on public API, README with usage examples, CLI --help output)\n- Compatibility/breaking changes/migrations (Go 1.21+ requirement documented)\n- Security/privacy considerations (safe file I/O, proper error handling, no arbitrary file write vulnerabilities)\n- Operational readiness (clear error messages, appropriate exit codes, verbose/debug flags)\n- Performance/reliability (SSIM thresholds documented, tracer handles 1000-point glyphs, round-trip tests pass)\n\nWrite to .ai/dod_c.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\nUse canonical schema: {\"status\":\"success\"}"
    ]

    consolidate_dod [
        prompt="Goal: $goal\n\nSynthesize the DoD proposals into a single consensus DoD for DTTF. Read .ai/spec.md.\n\nImportant: The DoD branches run in isolated worktrees when triggered via dod_fanout (shape=component).\nTo gather inputs:\n1) Read $KILROY_LOGS_ROOT/dod_fanout/parallel_results.json.\n2) From each branch worktree_dir, read:\n- .ai/dod_a.md\n- .ai/dod_b.md\n- .ai/dod_c.md\nIf parallel_results.json is missing, fall back to reading those files from the current worktree.\n\nOutput requirements:\n- Produce a single DoD that meets the DoD rubric (scope, deliverables, acceptance criteria, verification, quality/safety outcomes, non-goals).\n- Coverage checklist: explicitly address each item (include criteria, or mark N/A with a short reason):\n  - Build/package/install correctness (go build, go install)\n  - Automated tests (go test with coverage expectations)\n  - Lint/format/static analysis (gofmt, go vet)\n  - Documentation/user guidance (godoc, README, CLI help)\n  - Compatibility/breaking changes/migrations (Go version requirements)\n  - Security/privacy considerations (file I/O safety)\n  - Operational readiness (error handling, logging, exit codes)\n  - Performance/reliability (SSIM thresholds, tracer performance)\n- Prefer 'what' and 'evidence' over 'how'.\n- Remove contradictions; keep it realistically checkable.\n\nWrite the final DoD to .ai/definition_of_done.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\nUse canonical schema: {\"status\":\"success\"}"
    ]

    // =========================================================================
    // Planning Fanout
    // =========================================================================

    plan_fanout [shape=component, label="Plan Fan-Out"]

    plan_a [
        class="branch-a",
        prompt="Goal: $goal\n\nCreate an implementation plan for DTTF.\nRead .ai/spec.md and .ai/definition_of_done.md.\nIf .ai/postmortem_latest.md exists, incorporate its lessons.\n\nKey planning considerations:\n- Start with module structure and go.mod setup\n- Core data structures first (GlyphBitmap, Point, Contour, TracedGlyph, FontMetadata)\n- PNG loading and grayscale conversion\n- Bitmap tracer (4 phases: path decomposition, polygon, quadratic Bezier, font-aware optimization)\n- Font table assembly (10 required + 1 recommended table)\n- CLI command structure (build, rasterize, validate, test)\n- Test harness with SSIM computation\n- Comprehensive error handling\n\nWrite to .ai/plan_a.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\nUse canonical schema: {\"status\":\"success\"}"
    ]

    plan_b [
        class="branch-b",
        prompt="Goal: $goal\n\nCreate an implementation plan for DTTF.\nRead .ai/spec.md and .ai/definition_of_done.md.\nIf .ai/postmortem_latest.md exists, incorporate its lessons.\n\nKey planning considerations:\n- Start with module structure and go.mod setup\n- Core data structures first (GlyphBitmap, Point, Contour, TracedGlyph, FontMetadata)\n- PNG loading and grayscale conversion\n- Bitmap tracer (4 phases: path decomposition, polygon, quadratic Bezier, font-aware optimization)\n- Font table assembly (10 required + 1 recommended table)\n- CLI command structure (build, rasterize, validate, test)\n- Test harness with SSIM computation\n- Comprehensive error handling\n\nWrite to .ai/plan_b.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\nUse canonical schema: {\"status\":\"success\"}"
    ]

    plan_c [
        class="branch-c",
        prompt="Goal: $goal\n\nCreate an implementation plan for DTTF.\nRead .ai/spec.md and .ai/definition_of_done.md.\nIf .ai/postmortem_latest.md exists, incorporate its lessons.\n\nKey planning considerations:\n- Start with module structure and go.mod setup\n- Core data structures first (GlyphBitmap, Point, Contour, TracedGlyph, FontMetadata)\n- PNG loading and grayscale conversion\n- Bitmap tracer (4 phases: path decomposition, polygon, quadratic Bezier, font-aware optimization)\n- Font table assembly (10 required + 1 recommended table)\n- CLI command structure (build, rasterize, validate, test)\n- Test harness with SSIM computation\n- Comprehensive error handling\n\nWrite to .ai/plan_c.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\nUse canonical schema: {\"status\":\"success\"}"
    ]

    debate_consolidate [
        prompt="Goal: $goal\n\nSynthesize the planning branches into a best-of-breed final plan for DTTF.\n\nImportant: The planning branches run in isolated worktrees when triggered via plan_fanout (shape=component).\nTo gather inputs:\n1) Read $KILROY_LOGS_ROOT/plan_fanout/parallel_results.json.\n2) From each branch worktree_dir, read:\n- .ai/plan_a.md\n- .ai/plan_b.md\n- .ai/plan_c.md\nIf parallel_results.json is missing, fall back to reading those files from the current worktree.\n\nResolve conflicts. Ensure dependency order.\nIf .ai/postmortem_latest.md exists, verify the plan addresses every issue.\n\nCritical requirements:\n- Module initialization and directory structure must come first\n- Core types before functions that use them\n- Tracer before font assembly\n- Library functions before CLI commands\n- Basic functionality before test harness\n\nWrite to .ai/plan_final.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\nUse canonical schema: {\"status\":\"success\"}"
    ]

    // =========================================================================
    // Implementation and Verification
    // =========================================================================

    implement [
        shape=box,
        class="hard",
        max_retries=2,
        prompt="Goal: $goal\n\nCRITICAL: Check .ai/postmortem_latest.md existence FIRST.\n\nIf .ai/postmortem_latest.md EXISTS:\n- This is a REPAIR iteration — NOT a fresh implementation\n- Read .ai/postmortem_latest.md FIRST before doing anything else\n- Fix ONLY the specific gaps it identifies\n- Do NOT regenerate or rewrite systems already marked as working\n- Do NOT start over from scratch\n- Preserve all passing code and tests\n- Make surgical fixes to address the identified issues\n\nIf .ai/postmortem_latest.md DOES NOT EXIST:\n- This is a fresh implementation\n- Execute .ai/plan_final.md step-by-step\n- Create the module structure, core types, tracer, font assembly, CLI, tests\n\nIn BOTH cases:\n- Read .ai/definition_of_done.md for acceptance criteria\n- Use progressive compilation: get each module compiling before starting the next\n- Run `go build ./...` after each major stage to catch errors early\n- Log progress and decisions to .ai/implementation_log.md\n\nModule structure (fresh implementation):\n- cmd/dttf/main.go (CLI entry point)\n- internal/tracer/ (bitmap tracing)\n- internal/font/ (font assembly)\n- internal/quality/ (SSIM, validation)\n- internal/rasterizer/ (font rendering for tests)\n- pkg/dttf/ (public library API)\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\n\nIf `status` is `fail`, include:\n- failure_reason: short identifier (e.g., \"compilation_error\", \"missing_dependency\")\n- details: full error output or description\n- failure_class: \"deterministic\" (for code errors) or \"transient_infra\" (for network/timeout)\n- failure_signature: unique key for this specific failure (e.g., \"pkg_missing:image/png\")\n\nSet `status` to `success` if the implementation builds successfully; otherwise set `status` to `fail` with appropriate payload."
    ]

    check_implement [shape=diamond, label="Implement OK?"]

    fix_fmt [
        shape=parallelogram,
        max_retries=0,
        tool_command="gofmt -w .; echo 'Go formatting applied'"
    ]

    verify_fmt [
        shape=parallelogram,
        max_retries=0,
        tool_command="test -z \"$(gofmt -l .)\" || { echo 'ERROR: Files not gofmt-formatted:'; gofmt -l .; exit 1; }"
    ]

    check_fmt [shape=diamond, label="Fmt OK?"]

    verify_build [
        shape=parallelogram,
        tool_command="go build -v ./... && go build -v -o /tmp/dttf cmd/dttf/main.go && /tmp/dttf --help >/dev/null"
    ]

    check_build [shape=diamond, label="Build OK?"]

    verify_test [
        shape=parallelogram,
        tool_command="go test -v ./... -timeout 5m"
    ]

    check_test [shape=diamond, label="Tests OK?"]

    verify_vet [
        shape=parallelogram,
        max_retries=0,
        tool_command="go vet ./..."
    ]

    check_vet [shape=diamond, label="Vet OK?"]

    check_deliverables [
        shape=parallelogram,
        max_retries=0,
        tool_command="test -f cmd/dttf/main.go || { echo 'ERROR: cmd/dttf/main.go missing'; exit 1; }; test -d pkg/dttf || { echo 'ERROR: pkg/dttf/ missing'; exit 1; }; test -d internal/tracer || { echo 'ERROR: internal/tracer/ missing'; exit 1; }; test -d internal/font || { echo 'ERROR: internal/font/ missing'; exit 1; }; echo 'All deliverables present'"
    ]

    check_deliverables_cond [shape=diamond, label="Deliverables OK?"]

    verify_fidelity [
        shape=box,
        class="verify",
        prompt="Goal: $goal\n\nPerform semantic fidelity review after all deterministic checks pass.\n\nRead .ai/definition_of_done.md and .ai/spec.md.\n\nVerify:\n1. API completeness: Check that pkg/dttf/ exports Build(), LoadGlyphs(), TraceGlyph(), AssembleFont(), WriteFont() per spec section 4.2\n2. CLI commands: Verify cmd/dttf/main.go implements build, rasterize, validate, test subcommands per spec section 12\n3. Core pipeline stages: Verify internal/tracer/ implements 4-phase tracing (path decomposition, polygon, quadratic Bezier, font-aware optimization) per spec section 3.2\n4. Font tables: Verify internal/font/ creates all 10 required + 1 recommended TrueType tables per spec section 2.2\n5. Quality function: Verify internal/quality/ implements SSIM computation and validation checks per spec section 5\n6. Test harness: Verify test package implements round-trip test (render, trace, compare) per spec section 6.1\n7. Error handling: Verify proper error propagation and user-facing messages per spec section 9\n8. Data structures: Verify types match spec section 7.1 (GlyphBitmap, Point, Contour, TracedGlyph, FontMetadata)\n\nFor each item:\n- PASS if implementation exists and matches spec intent\n- FAIL if missing, incomplete, or diverges from spec requirements\n\nWrite findings to .ai/verify_fidelity.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\n\nIf `status` is `fail`, include:\n- failure_reason: \"semantic_fidelity_gap\"\n- details: full list of each specific gap found\n- failure_class: \"deterministic\"\n- failure_signature: sorted comma-separated list of failed criteria identifiers (e.g., \"API-1,CLI-2,Tracer-3\")\n\nSet `status` to `success` if all criteria pass; otherwise set `status` to `fail` with appropriate payload."
    ]

    check_impl [shape=diamond, label="Impl OK?"]

    // =========================================================================
    // Review Fanout
    // =========================================================================

    review_fanout [shape=component, label="Review Fan-Out"]

    review_a [
        class="review",
        prompt="Goal: $goal\n\nReview the DTTF implementation against .ai/definition_of_done.md.\n\nCheck:\n1. Build correctness (go build succeeds, binary runs)\n2. Test coverage (go test passes, core pipeline tested)\n3. Code quality (gofmt clean, go vet clean, godoc comments present)\n4. Spec compliance (all required features implemented per .ai/spec.md)\n5. Error handling (proper error messages, safe file I/O)\n6. Documentation (README, CLI help, API docs)\n\nWrite review to .ai/review_a.md with:\n- Clear APPROVED or REJECTED verdict\n- Specific evidence for each DoD criterion\n- List of any gaps or concerns\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\n\nIf `status` is `fail`, include:\n- failure_reason: short identifier for primary gap (e.g., \"missing_tests\", \"incomplete_api\")\n- details: full list of gaps found\n\nSet `status` to `success` if the implementation meets all DoD criteria; otherwise set `status` to `fail`."
    ]

    review_b [
        class="review",
        prompt="Goal: $goal\n\nReview the DTTF implementation against .ai/definition_of_done.md.\n\nCheck:\n1. Build correctness (go build succeeds, binary runs)\n2. Test coverage (go test passes, core pipeline tested)\n3. Code quality (gofmt clean, go vet clean, godoc comments present)\n4. Spec compliance (all required features implemented per .ai/spec.md)\n5. Error handling (proper error messages, safe file I/O)\n6. Documentation (README, CLI help, API docs)\n\nWrite review to .ai/review_b.md with:\n- Clear APPROVED or REJECTED verdict\n- Specific evidence for each DoD criterion\n- List of any gaps or concerns\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\n\nIf `status` is `fail`, include:\n- failure_reason: short identifier for primary gap (e.g., \"missing_tests\", \"incomplete_api\")\n- details: full list of gaps found\n\nSet `status` to `success` if the implementation meets all DoD criteria; otherwise set `status` to `fail`."
    ]

    review_c [
        class="review",
        prompt="Goal: $goal\n\nReview the DTTF implementation against .ai/definition_of_done.md.\n\nCheck:\n1. Build correctness (go build succeeds, binary runs)\n2. Test coverage (go test passes, core pipeline tested)\n3. Code quality (gofmt clean, go vet clean, godoc comments present)\n4. Spec compliance (all required features implemented per .ai/spec.md)\n5. Error handling (proper error messages, safe file I/O)\n6. Documentation (README, CLI help, API docs)\n\nWrite review to .ai/review_c.md with:\n- Clear APPROVED or REJECTED verdict\n- Specific evidence for each DoD criterion\n- List of any gaps or concerns\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\n\nIf `status` is `fail`, include:\n- failure_reason: short identifier for primary gap (e.g., \"missing_tests\", \"incomplete_api\")\n- details: full list of gaps found\n\nSet `status` to `success` if the implementation meets all DoD criteria; otherwise set `status` to `fail`."
    ]

    review_consensus [
        goal_gate=true,
        class="review",
        prompt="Goal: $goal\n\nSynthesize the review branches into a single consensus.\nRead .ai/definition_of_done.md for criteria.\n\nImportant: The review branches run in isolated worktrees when triggered via review_fanout (shape=component).\nTo gather inputs:\n1) Read $KILROY_LOGS_ROOT/review_fanout/parallel_results.json.\n2) From each branch worktree_dir, read:\n- .ai/review_a.md\n- .ai/review_b.md\n- .ai/review_c.md\nIf parallel_results.json is missing, fall back to reading those files from the current worktree.\n\nConsensus policy:\n- If 2+ reviewers APPROVED and no critical gaps: set `status` to `success`.\n- If 1 or fewer APPROVED, or critical gaps exist: set `status` to `retry` with detailed gap list.\n\nWrite consensus to .ai/review_consensus.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\n\nIf `status` is `retry`, include:\n- failure_reason: \"consensus_not_met\" or \"critical_gaps_found\"\n- details: consolidated list of all issues requiring repair\n\nSet `status` to `success` if 2+ reviewers approved; otherwise set `status` to `retry`."
    ]

    // =========================================================================
    // Postmortem
    // =========================================================================

    postmortem [
        shape=box,
        prompt="Goal: $goal\n\nAnalyze why the implementation failed and provide actionable guidance for the next iteration.\n\nInputs to read:\n- .ai/review_consensus.md (if it exists)\n- .ai/implementation_log.md (if it exists)\n- .ai/verify_fidelity.md (if it exists)\n\nImportant: The review branches run in isolated worktrees when triggered via review_fanout (shape=component).\nTo gather review inputs:\n1) Read $KILROY_LOGS_ROOT/review_fanout/parallel_results.json.\n2) From each branch worktree_dir, read:\n- .ai/review_a.md\n- .ai/review_b.md\n- .ai/review_c.md\nIf parallel_results.json is missing, fall back to reading those files from the current worktree.\n\nAnalysis:\n- Identify root causes (not just symptoms)\n- Distinguish between: missing features, incorrect implementations, insufficient tests, quality issues\n- Determine what worked and should be preserved\n- Determine what failed and needs fixing\n- Provide specific, actionable fixes (file paths, function names, concrete changes)\n\nCritical instruction for next iteration:\nThe next implement node MUST NOT start from scratch. It must:\n1. Read this postmortem first\n2. Preserve all working code\n3. Make only the surgical fixes identified here\n4. Reuse existing tests and add missing ones\n\nWrite to .ai/postmortem_latest.md (overwrite any previous postmortem).\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path).\nIf unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH.\nDo not write nested status.json files after cd.\n\nYour status reflects whether you completed the analysis, not the state of the implementation.\nSet `status` to `success` when .ai/postmortem_latest.md is written."
    ]

    // =========================================================================
    // Flow
    // =========================================================================

    // Bootstrap
    start -> check_toolchain
    check_toolchain -> expand_spec [condition="outcome=success"]
    check_toolchain -> check_toolchain [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_toolchain -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_toolchain -> postmortem
    expand_spec -> check_dod

    // DoD routing
    check_dod -> dod_fanout [condition="outcome=needs_dod"]
    check_dod -> plan_fanout [condition="outcome=has_dod"]
    check_dod -> plan_fanout
    dod_fanout -> dod_a
    dod_fanout -> dod_b
    dod_fanout -> dod_c
    dod_a -> consolidate_dod
    dod_b -> consolidate_dod
    dod_c -> consolidate_dod
    consolidate_dod -> plan_fanout

    // Planning
    plan_fanout -> plan_a
    plan_fanout -> plan_b
    plan_fanout -> plan_c
    plan_a -> debate_consolidate
    plan_b -> debate_consolidate
    plan_c -> debate_consolidate
    debate_consolidate -> implement

    // Implementation and verification
    implement -> check_implement
    check_implement -> fix_fmt [condition="outcome=success"]
    check_implement -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_implement -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_implement -> postmortem

    fix_fmt -> verify_fmt
    verify_fmt -> check_fmt
    check_fmt -> verify_build [condition="outcome=success"]
    check_fmt -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_fmt -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_fmt -> postmortem

    verify_build -> check_build
    check_build -> verify_test [condition="outcome=success"]
    check_build -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_build -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_build -> postmortem

    verify_test -> check_test
    check_test -> verify_vet [condition="outcome=success"]
    check_test -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_test -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_test -> postmortem

    verify_vet -> check_vet
    check_vet -> check_deliverables [condition="outcome=success"]
    check_vet -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_vet -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_vet -> postmortem

    check_deliverables -> check_deliverables_cond
    check_deliverables_cond -> verify_fidelity [condition="outcome=success"]
    check_deliverables_cond -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_deliverables_cond -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_deliverables_cond -> postmortem

    verify_fidelity -> check_impl
    check_impl -> review_fanout [condition="outcome=success"]
    check_impl -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_impl -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_impl -> postmortem

    // Review
    review_fanout -> review_a
    review_fanout -> review_b
    review_fanout -> review_c
    review_a -> review_consensus
    review_b -> review_consensus
    review_c -> review_consensus

    // Terminal routing
    review_consensus -> exit [condition="outcome=success"]
    review_consensus -> postmortem

    // Hill-climbing loop
    postmortem -> check_toolchain
}
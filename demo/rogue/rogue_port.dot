digraph rogue_wasm_port {
    graph [
        goal="Port the classic Rogue 5.4.4 game from C to Rust/WASM, playable in a browser with classic ASCII terminal rendering — exact mechanical port of all game systems",
        rankdir=LR,
        default_max_retry=3,
        retry_target="impl_integration",
        fallback_retry_target="impl_scaffold",
        default_command_timeout_ms=300000,
        max_command_timeout_ms=1800000,
        model_stylesheet="
            * { llm_model: gpt-5.2-codex; llm_provider: openai; }
            .hard { llm_model: gpt-5.2-codex; llm_provider: openai; }
            .verify { llm_model: gpt-5.2-codex; llm_provider: openai; reasoning_effort: high; }
            .review { llm_model: gpt-5.2-codex; llm_provider: openai; reasoning_effort: high; }
        "
    ]

    start [shape=Mdiamond, label="Start"]
    exit  [shape=Msquare, label="Exit"]
    check_toolchain [
        shape=parallelogram,
        max_retries=0,
        tool_command="bash -lc 'set -euo pipefail; command -v cargo >/dev/null || { echo \"missing required tool: cargo\" >&2; exit 1; }; command -v rustup >/dev/null || { echo \"missing required tool: rustup (install via rustup.rs)\" >&2; exit 1; }; command -v wasm-pack >/dev/null || { echo \"missing required tool: wasm-pack (install with: cargo install wasm-pack)\" >&2; exit 1; }; rustup target list --installed | grep -qx wasm32-unknown-unknown || { echo \"missing required rust target: wasm32-unknown-unknown (install with: rustup target add wasm32-unknown-unknown)\" >&2; exit 1; }'"
    ]

    // =========================================================================
    // Phase 1: Spec expansion — bootstrap .ai/spec.md from inline requirements
    // =========================================================================

    expand_spec [
        shape=box,
        auto_status=true,
        max_agent_turns=15,
        prompt="You are bootstrapping a spec for a large C-to-Rust/WASM port.\n\nRequirements:\n- Port the classic Rogue 5.4.4 game (C source at demo/rogue/original-rogue/, ~16,800 lines across 33 .c files) to Rust compiled to WASM, playable on an HTML page.\n- Exact mechanical port: same dungeon generation algorithms, monster stats, item tables, RNG seed behavior. 1:1 Rust translation.\n- Full scope: dungeon gen, combat, all item types (potions/scrolls/rings/sticks/weapons/armor), monster AI, save/load, scoring, wizard mode, options, daemons/fuses.\n- Rendering: classic ASCII in a terminal-style grid (xterm.js or custom HTML/CSS grid). '@' player, '#' corridors, '.' floors.\n- Build: Rust -> WASM via wasm-pack + wasm-bindgen, served from a single HTML page at demo/rogue/rogue-wasm/.\n\nSource structure (demo/rogue/original-rogue/):\n  Core: main.c (396L), command.c (820L), rogue.h (753L), extern.h (197L), extern.c (391L)\n  Dungeon: rooms.c (472L), passages.c (424L), new_level.c (231L)\n  Combat: fight.c (686L), weapons.c (288L), armor.c (89L)\n  Items: potions.c (375L), scrolls.c (329L), rings.c (204L), sticks.c (431L), things.c (713L)\n  Monsters: monsters.c (252L), chase.c (541L), daemon.c (181L), daemons.c (295L)\n  Player: move.c (425L), pack.c (503L), list.c (113L)\n  UI/IO: io.c (277L), rip.c (449L), options.c (501L)\n  State: state.c (2134L), save.c (390L), init.c (447L)\n  Platform: mach_dep.c (457L), mdport.c (1432L)\n  Misc: misc.c (597L), wizard.c (284L), xcrypt.c (707L), vers.c (17L)\n\nDisambiguation / Assumptions:\n- The C source uses ncurses; the Rust port replaces ncurses with a WASM-exported API that a JS terminal renderer consumes.\n- The THING union in C becomes a Rust enum with Monster and Object variants.\n- The global-heavy C architecture maps to a GameState struct in Rust.\n- Save/load serializes GameState to localStorage via web-sys.\n- No networking or multiplayer — single-player browser game.\n\nExpand into a detailed spec covering:\n1. Project layout (Cargo.toml, src/ modules, www/ HTML/JS/CSS)\n2. Rust module map (which C files map to which Rust modules)\n3. Core type definitions (coord, Thing, Place, Room, Stats, Monster, ObjInfo)\n4. WASM bridge API (functions exported to JS, JS->Rust event flow)\n5. Terminal renderer spec (grid dimensions, character rendering, color, input handling)\n6. RNG porting strategy (must reproduce original seed behavior)\n7. System-by-system porting notes for each C file group\n8. Build commands (wasm-pack build, npm/npx serve)\n9. Test plan (unit tests per module, integration test via wasm-pack test)\n10. Acceptance criteria\n\nWrite the spec to .ai/spec.md.\nWrite status.json: outcome=success"
    ]

    // =========================================================================
    // Phase 2: Deep C source analysis
    // =========================================================================

    impl_analysis [
        shape=box,
        class="hard",
        max_agent_turns=25,
        prompt="Goal: $goal\n\nPerform a deep analysis of the entire Rogue C source at demo/rogue/original-rogue/.\n\nRead EVERY .c and .h file. Catalog:\n1. All data structures (structs, unions, typedefs) with field-level detail\n2. All global variables (from extern.c, extern.h, rogue.h) — name, type, initial value, which files read/write them\n3. All #define constants and macros — especially the gameplay ones (MAXROOMS, AMULETLEVEL, HUNGERTIME, etc.) and the convenience macros (when, otherwise, until, ce, hero, pstats, etc.)\n4. Every function signature grouped by source file, with brief description of what it does\n5. Cross-file dependency graph — which files call functions from which other files\n6. The ncurses API surface — every ncurses function/macro used (mvaddch, move, refresh, getch, WINDOW, etc.) and where\n7. The game loop flow: main() -> playit() -> command() -> do_daemons/do_fuses -> monster movement\n8. Memory management patterns (malloc/free, linked list attach/detach)\n9. The RNG implementation (seed*11109+13849 >> 16, and rnd/roll/spread functions)\n10. Platform-specific code in mach_dep.c and mdport.c that needs WASM equivalents\n\nWrite the complete analysis to .ai/rogue_analysis.md.\n\nWrite status.json: outcome=success"
    ]

    verify_analysis [
        shape=box,
        class="verify",
        max_agent_turns=8,
        prompt="Verify the C source analysis is comprehensive.\n\nRead .ai/rogue_analysis.md. Cross-check against the actual C source:\n1. Confirm all 33 .c files are covered\n2. Confirm all structs from rogue.h are documented (THING, PLACE, room, stats, monster, obj_info, h_list, coord, delayed_action)\n3. Confirm all global variables from extern.c are listed\n4. Spot-check 5 random functions — verify the analysis describes them accurately\n5. Confirm the ncurses API surface is listed\n6. Confirm the RNG algorithm is correctly documented\n\nWrite results to .ai/verify_analysis.md.\nWrite status.json: outcome=success if comprehensive, outcome=fail with gaps identified."
    ]

    check_analysis [shape=diamond, label="Analysis OK?"]

    // =========================================================================
    // Phase 3: Architecture design
    // =========================================================================

    impl_architecture [
        shape=box,
        class="hard",
        max_agent_turns=20,
        prompt="Goal: $goal\n\nRead .ai/spec.md and .ai/rogue_analysis.md.\n\nDesign the Rust/WASM architecture for the port. Write .ai/rogue_architecture.md covering:\n\n1. **Rust Module Layout**\n   - src/lib.rs (WASM entry, exports)\n   - src/types.rs (coord, Thing enum, Place, Room, Stats, Monster, ObjInfo, constants)\n   - src/rng.rs (exact port of the C RNG)\n   - src/game.rs (GameState struct holding all globals, game loop)\n   - src/dungeon.rs (rooms, passages, new_level, maze)\n   - src/combat.rs (fight, hit/miss, damage rolls)\n   - src/items.rs (potions, scrolls, rings, sticks, things, weapons, armor)\n   - src/monsters.rs (monster defs, chase AI, spawn)\n   - src/daemon.rs (daemon/fuse scheduling)\n   - src/player.rs (movement, commands, pack/inventory)\n   - src/io.rs (message system, status line, help)\n   - src/state.rs (save/load serialization)\n   - src/init.rs (initialization, options, names/colors/stones)\n   - src/score.rs (scoring, death screen, tombstone)\n   - src/wizard.rs (wizard mode commands)\n\n2. **C-to-Rust Type Mappings**\n   - THING union -> enum Thing { Monster{...}, Object{...} } with shared linked-list replaced by Vec or arena\n   - Global variables -> GameState struct fields\n   - ncurses WINDOW -> a 80x24 char grid buffer exported to JS\n   - C macros -> Rust const/inline fn\n   - C bit flags -> bitflags! macro\n\n3. **WASM Bridge API**\n   - Exported: new_game(seed) -> GameHandle, process_key(key) -> FrameUpdate, get_screen() -> [u8; 80*24], get_status_line() -> String, get_message() -> String\n   - FrameUpdate: { screen: Vec<Cell>, status: String, message: String, game_over: bool }\n   - Cell: { ch: char, fg: Color, bg: Color, bold: bool }\n\n4. **JS Terminal Renderer**\n   - 80x24 grid of <span> elements in a <pre> or CSS grid\n   - Keyboard event listener -> process_key()\n   - RequestAnimationFrame render loop reading get_screen()\n   - Color mapping for the 8 curses colors\n\n5. **HTML Shell**\n   - Single index.html with embedded CSS/JS\n   - Loads WASM, creates terminal grid, handles I/O\n\n6. **ncurses Replacement Strategy**\n   - Map each ncurses call to GameState buffer operations\n   - mvaddch(y,x,ch) -> game.screen[y][x] = ch\n   - refresh() -> mark frame dirty (JS polls on next rAF)\n   - getch() -> async key queue from JS\n   - All output buffered in GameState, flushed to JS on each turn\n\n7. **Cross-Module Interface Contracts**\n   - Define the exact function signatures each module must export\n   - This is what the parallel port branches will implement against\n\nWrite status.json: outcome=success"
    ]

    verify_architecture [
        shape=box,
        class="verify",
        max_agent_turns=8,
        prompt="Verify the architecture design.\n\nRead .ai/rogue_architecture.md and .ai/rogue_analysis.md.\n1. Confirm every C source file has a clear Rust module assignment\n2. Confirm every C struct/union has a Rust type mapping\n3. Confirm the WASM bridge API covers all user interactions (movement, combat, inventory, quaff, read, wield, wear, zap, etc.)\n4. Confirm the ncurses replacement strategy covers all used ncurses functions from the analysis\n5. Confirm cross-module interfaces are defined\n\nWrite results to .ai/verify_architecture.md.\nWrite status.json: outcome=success if complete, outcome=fail with gaps."
    ]

    check_architecture [shape=diamond, label="Architecture OK?"]

    // =========================================================================
    // Phase 4: Scaffold project + core types
    // =========================================================================

    impl_scaffold [
        shape=box,
        class="hard",
        max_agent_turns=25,
        max_retries=2,
        prompt="Goal: $goal\n\nRead .ai/spec.md and .ai/rogue_architecture.md.\n\nCreate the Rust/WASM project scaffold at demo/rogue/rogue-wasm/:\n\n1. **Cargo.toml** with:\n   - [lib] crate-type = [\"cdylib\", \"rlib\"]\n   - wasm-bindgen, web-sys (features: Document, Element, HtmlElement, Window, KeyboardEvent, console), js-sys\n   - serde + serde_json (for save/load)\n   - bitflags\n   - wasm-bindgen-test (dev)\n\n2. **src/lib.rs** — WASM entry point with #[wasm_bindgen] exports:\n   - new_game(seed: u32) -> Game\n   - Game::process_key(key: &str) -> JsValue (returns FrameUpdate as JSON)\n   - Game::get_screen() -> Vec<u8> (flattened 80x24 grid)\n   - Stub implementations that compile\n\n3. **src/types.rs** — Port ALL core types from rogue.h:\n   - Coord { x: i32, y: i32 }\n   - Stats { str: u32, exp: i32, lvl: i32, arm: i32, hpt: i32, dmg: String, maxhp: i32 }\n   - Thing enum with Monster and Object variants (all fields from C union)\n   - Place { ch: char, flags: u8, monst: Option<usize> } (index into arena)\n   - Room { pos: Coord, max: Coord, gold: Coord, goldval: i32, flags: u16, nexits: i32, exits: [Coord; 12] }\n   - Monster { name: String, carry: i32, flags: u16, stats: Stats }\n   - ObjInfo { name: String, prob: i32, worth: i32, guess: String, know: bool }\n   - All constants: MAXROOMS, MAXTHINGS, MAXOBJ, MAXPACK, AMULETLEVEL, NUMLINES, NUMCOLS, all item/weapon/armor/ring/stick type constants, all flag bits, trap types, potion types, scroll types\n   - bitflags! for room flags, object flags, creature flags, map flags\n   - HelpEntry { ch: char, desc: &'static str, print: bool }\n   - DelayedAction { d_type: i32, d_func: fn(&mut GameState), d_arg: i32, d_time: i32 }\n\n4. **src/rng.rs** — Exact port of the C RNG:\n   - struct Rng { seed: i32 }\n   - rn(&mut self) -> u16 — the (seed*11109+13849) >> 16 & 0xffff formula\n   - rnd(&mut self, range: i32) -> i32\n   - roll(&mut self, number: i32, sides: i32) -> i32\n   - spread(&mut self, nm: i32) -> i32\n\n5. **src/game.rs** — GameState struct (stub) holding all the globals from extern.c:\n   - All bool flags (after, again, playing, running, etc.)\n   - All char/string state (file_name, whoami, fruit, etc.)\n   - All int state (level, purse, no_food, etc.)\n   - places: [Place; MAXCOLS * MAXLINES], rooms: [Room; MAXROOMS], etc.\n   - player: Thing, mlist: Vec<Thing>, lvl_obj: Vec<Thing>\n   - cur_weapon, cur_armor, cur_ring as Option<usize>\n   - Rng instance\n\n6. **Stub module files** for all other modules (dungeon.rs, combat.rs, items.rs, monsters.rs, daemon.rs, player.rs, io_bridge.rs, state.rs, init.rs, score.rs, wizard.rs) — each with a comment describing what it will contain and empty pub fn stubs matching the architecture interfaces.\n\n7. **www/index.html** — Single HTML page:\n   - A <pre id=\"terminal\"> element styled for 80x24 monospace grid\n   - CSS: black background, green-on-black text, fixed-width font\n   - JS: load WASM via wasm-bindgen glue, keyboard listener, render loop\n   - Stub JS that shows \"Loading Rogue...\" then initializes\n\nAfter creating everything, run:\n  cd demo/rogue/rogue-wasm && wasm-pack build --target web 2>&1 || cargo build --lib 2>&1\n\nThe project MUST compile (even if stubs return dummy values).\n\nWrite status.json: outcome=success if it compiles, outcome=fail with errors."
    ]

    verify_scaffold [
        shape=box,
        class="verify",
        max_agent_turns=8,
        prompt="Verify the project scaffold.\n\nRun:\n1. cd demo/rogue/rogue-wasm && cargo build --lib 2>&1\n2. Check that src/types.rs defines Coord, Thing, Place, Room, Stats, Monster, ObjInfo, and all constants\n3. Check that src/rng.rs implements the exact C RNG formula\n4. Check that src/game.rs defines GameState with all global equivalents\n5. Check that all stub module files exist\n6. Check that www/index.html exists with terminal grid markup\n7. Verify Cargo.toml has wasm-bindgen, web-sys, serde, bitflags dependencies\n\nWrite results to .ai/verify_scaffold.md.\nWrite status.json: outcome=success if all pass, outcome=fail with details."
    ]

    check_scaffold [shape=diamond, label="Scaffold OK?"]

    // =========================================================================
    // Phase 5: Parallel system port — FANOUT
    // =========================================================================

    fanout [shape=component, label="Fan Out: Port Systems"]

    // --- Branch A: Dungeon Generation (codex) ---

    impl_dungeon [
        shape=box,
        class="hard",
        max_agent_turns=25,
        max_retries=2,
        llm_model="gpt-5.2-codex",
        llm_provider="openai",
        prompt="Goal: $goal\n\nYou are porting the dungeon generation system from C to Rust.\n\nRead these C source files carefully:\n- demo/rogue/original-rogue/rooms.c (room generation, maze generation, treasure rooms)\n- demo/rogue/original-rogue/passages.c (corridor generation, passage connections)\n- demo/rogue/original-rogue/new_level.c (level initialization, stair placement)\n- demo/rogue/original-rogue/rogue.h (all constants, macros, data structures)\n\nRead the Rust project:\n- demo/rogue/rogue-wasm/src/types.rs (Rust types you must use)\n- demo/rogue/rogue-wasm/src/game.rs (GameState struct you must modify)\n- demo/rogue/rogue-wasm/.ai/rogue_architecture.md (module interfaces)\n\nImplement demo/rogue/rogue-wasm/src/dungeon.rs with EXACT ports of:\n\n1. **do_rooms()** — Generate 3x3 grid of rooms with random sizes/positions, handle dark rooms, gone rooms (corridors), maze rooms. Port the room size/position randomization exactly.\n2. **draw_room()** — Draw room walls (horiz/vert lines), floor, handle gone rooms.\n3. **horiz() / vert()** — Draw horizontal/vertical room borders.\n4. **door()** — Place doors on room edges.\n5. **do_passages()** — Connect rooms with corridors using the connection algorithm.\n6. **conn()** — Connect two specific rooms with a passage.\n7. **add_pass() / passnum() / numpass()** — Passage numbering and flag management.\n8. **new_level()** — Full level generation: clear map, generate rooms, passages, place stairs, place objects, place traps, place gold.\n9. **do_maze()** — Maze generation algorithm (recursive, using accnt_maze).\n10. **accnt_maze()** — Maze accounting helper.\n11. **treas_room()** — Treasure room generation.\n12. **rnd_room()** — Pick a random non-gone room.\n13. **find_floor()** — Find an empty floor position in a room.\n\nThe port must be EXACT — same algorithms, same constants, same randomization behavior. Use the GameState.rng for all random calls. Write to the GameState.places grid and GameState.rooms array.\n\nUpdate game.rs to add any needed helper methods on GameState.\n\nRun: cd demo/rogue/rogue-wasm && cargo build --lib 2>&1\n\nWrite implementation log to .ai/port_dungeon.md.\nWrite status.json: outcome=success if compiles, outcome=fail with errors."
    ]

    verify_dungeon [
        shape=box,
        class="verify",
        max_agent_turns=8,
        llm_model="gpt-5.2-codex",
        llm_provider="openai",
        prompt="Verify dungeon generation port.\n\nRun: cd demo/rogue/rogue-wasm && cargo build --lib 2>&1\n\nCompare demo/rogue/rogue-wasm/src/dungeon.rs against demo/rogue/original-rogue/rooms.c, passages.c, new_level.c:\n1. Confirm all 13 functions listed above are implemented\n2. Spot-check do_rooms() — same 3x3 grid layout, same size randomization\n3. Spot-check conn() — same corridor connection algorithm\n4. Spot-check new_level() — same initialization sequence\n5. Confirm maze generation matches C implementation\n\nWrite results to .ai/verify_dungeon.md.\nWrite status.json: outcome=success if compiles and faithful, outcome=fail with discrepancies."
    ]

    check_dungeon [shape=diamond, label="Dungeon OK?"]

    // --- Branch B: Combat, Items & Equipment (opus) ---

    impl_combat_items [
        shape=box,
        class="hard",
        max_agent_turns=25,
        max_retries=2,
        llm_model="gpt-5.2-codex",
        llm_provider="openai",
        prompt="Goal: $goal\n\nYou are porting the combat and item systems from C to Rust.\n\nRead these C source files carefully:\n- demo/rogue/original-rogue/fight.c (combat mechanics, attack/defense rolls)\n- demo/rogue/original-rogue/weapons.c (weapon types, damage strings, missile)\n- demo/rogue/original-rogue/armor.c (armor types, rust, protection)\n- demo/rogue/original-rogue/potions.c (14 potion types and effects)\n- demo/rogue/original-rogue/scrolls.c (18 scroll types and effects)\n- demo/rogue/original-rogue/rings.c (14 ring types and effects)\n- demo/rogue/original-rogue/sticks.c (14 wand/staff types and effects, bolt bouncing)\n- demo/rogue/original-rogue/things.c (item generation, naming, identification, inventory display)\n- demo/rogue/original-rogue/rogue.h (all type constants, flag bits)\n\nRead the Rust project:\n- demo/rogue/rogue-wasm/src/types.rs (Rust types)\n- demo/rogue/rogue-wasm/src/game.rs (GameState)\n- demo/rogue/rogue-wasm/.ai/rogue_architecture.md\n\nImplement:\n\n**demo/rogue/rogue-wasm/src/combat.rs:**\n- fight() — melee combat resolution\n- attack() — player attacks monster\n- hit_monster() — resolve hit on monster at position\n- swing() — to-hit roll calculation\n- roll_em() — damage roll with dice parsing (\"2d6+3\" style from s_dmg strings)\n- hit() / miss() — combat message formatting\n- bounce() — bolt/wand projectile bouncing off walls\n- fire_bolt() — fire a bolt in a direction\n- killed() — handle monster death, XP, drops\n- thunk() — thrown weapon messages\n- save_throw() — saving throw calculation\n- is_magic() — check if item is magical\n- check_level() — check for player level-up\n- raise_level() — actually level up\n\n**demo/rogue/rogue-wasm/src/items.rs:**\n- new_thing() — generate random item with probability tables\n- pick_one() — weighted random selection from obj_info table\n- inv_name() — format item name for inventory display\n- money() — create gold pile\n- set_know() / set_order() — knowledge tracking\n- nameit() / choose_str() / nullstr() / vowelstr() — name formatting helpers\n- pick_color() — random potion color selection\n- charge_str() / ring_num() / num() — stat formatting\n- do_pot() — apply potion effect (all 14 types)\n- quaff() — drink a potion\n- read_scroll() — read a scroll (all 18 types)\n- ring_on() / ring_off() / ring_eat() — ring management\n- do_zap() / fix_stick() — wand/staff usage\n- missile() / do_motion() — thrown weapon physics\n- drop() / dropcheck() — drop item, cursed check\n- eat() — eat food\n- wear() / take_off() — armor management\n- wield() — weapon management\n- current() — describe current equipment\n- whatis() / identify() / call() / call_it() — identification system\n- init_weapon() — initialize weapon stats\n- fall() — item falls to floor\n- add_pack() / pack_room() / leave_pack() / inventory() — pack management\n- pick_up() — pick up item from floor\n\nAll static data tables (pot_info, scr_info, ring_info, ws_info, weap_info, arm_info, things) must be ported exactly with original probability weights and names.\n\nThe port must be EXACT — same damage dice, same probability tables, same effect logic.\n\nRun: cd demo/rogue/rogue-wasm && cargo build --lib 2>&1\n\nWrite implementation log to .ai/port_combat_items.md.\nWrite status.json: outcome=success if compiles, outcome=fail with errors."
    ]

    verify_combat_items [
        shape=box,
        class="verify",
        max_agent_turns=8,
        llm_model="gpt-5.2-codex",
        llm_provider="openai",
        prompt="Verify combat and items port.\n\nRun: cd demo/rogue/rogue-wasm && cargo build --lib 2>&1\n\nCompare against C source:\n1. Confirm fight()/attack()/swing()/roll_em() match fight.c exactly\n2. Confirm all 14 potion effects match potions.c\n3. Confirm all 18 scroll effects match scrolls.c\n4. Confirm ring/stick handling matches rings.c and sticks.c\n5. Confirm probability tables match things.c\n6. Confirm weapon damage strings match weapons.c\n7. Confirm armor AC values match armor.c\n\nWrite results to .ai/verify_combat_items.md.\nWrite status.json: outcome=success if compiles and faithful, outcome=fail with discrepancies."
    ]

    check_combat_items [shape=diamond, label="Combat/Items OK?"]

    // --- Branch C: Monsters, AI & Daemons (glm-4.7) ---

    impl_monsters [
        shape=box,
        class="hard",
        max_agent_turns=25,
        max_retries=2,
        llm_model="glm-4.7",
        llm_provider="zai",
        prompt="Goal: $goal\n\nYou are porting the monster, AI, and daemon systems from C to Rust.\n\nRead these C source files carefully:\n- demo/rogue/original-rogue/monsters.c (26 monster definitions with stats)\n- demo/rogue/original-rogue/chase.c (monster AI, pathfinding, chase logic)\n- demo/rogue/original-rogue/daemon.c (daemon/fuse scheduling engine)\n- demo/rogue/original-rogue/daemons.c (specific daemons: runners, doctor, stomach, swander)\n- demo/rogue/original-rogue/misc.c (monster-related: aggravate, set_oldch, find_dest, rndmove, relocate)\n- demo/rogue/original-rogue/rogue.h (monster flags, structs)\n\nRead the Rust project:\n- demo/rogue/rogue-wasm/src/types.rs\n- demo/rogue/rogue-wasm/src/game.rs\n- demo/rogue/rogue-wasm/.ai/rogue_architecture.md\n\nImplement:\n\n**demo/rogue/rogue-wasm/src/monsters.rs:**\n- MONSTERS static array — all 26 monster types (A-Z) with exact stats: name, carry%, flags, STR, EXP, LVL, AC, HP, damage string. This data is in the monsters[] array in monsters.c.\n- new_monster() — place a new monster, set stats from template\n- randmonster() — pick random monster appropriate for level\n- wanderer() — spawn wandering monster\n- wake_monster() — wake monster when player enters room\n- give_pack() — give monster random inventory\n- see_monst() — can player see this monster?\n- set_mname() — get monster's display name\n- remove_mon() — remove monster from level\n- find_dest() — determine monster's target destination\n- rndmove() — random monster movement\n- relocate() — move monster to new position\n- aggravate() — wake all monsters\n- set_oldch() — save character under monster\n\n**demo/rogue/rogue-wasm/src/daemon.rs:**\n- d_list array of DelayedAction — daemon/fuse slots (MAXDAEMONS=20)\n- start_daemon() — register a recurring daemon\n- kill_daemon() — remove a daemon\n- do_daemons() — run all active daemons (BEFORE or AFTER flag)\n- fuse() — register a one-time delayed action\n- lengthen() — extend a fuse timer\n- extinguish() — cancel a fuse\n- do_fuses() — tick and fire fuses\n\n**Specific daemons (in daemon.rs or a sub-module):**\n- runners() — move all running monsters\n- doctor() — player HP regeneration (1 HP per HEALTIME turns, scaled by level)\n- stomach() — hunger system (HUNGERTIME countdown, states: normal->hungry->weak->faint->starve)\n- swander() — spawn wandering monsters (WANDERTIME countdown)\n- come_down() — end hallucination\n- unconfuse() — end confusion\n- unsee() — end see-invisible\n- sight() / visuals() — visual effects management\n- nohaste() — end haste\n- land() — end levitation\n- rollwand() — end wand effect\n\n**Chase AI (in monsters.rs or chase.rs):**\n- chase() — main monster chase logic: move toward player, handle doors/passages\n- do_chase() — execute one chase step for a monster\n- runto() — set monster running toward coordinate\n- move_monst() — move monster one step\n- diag_ok() — can monster move diagonally?\n- cansee() — line of sight check\n- dist() / dist_cp() — distance calculations\n- turn_ok() — can monster step here?\n\nThe port must be EXACT — same monster stats table, same chase algorithm, same daemon timing.\n\nRun: cd demo/rogue/rogue-wasm && cargo build --lib 2>&1\n\nWrite implementation log to .ai/port_monsters.md.\nWrite status.json: outcome=success if compiles, outcome=fail with errors."
    ]

    verify_monsters [
        shape=box,
        class="verify",
        max_agent_turns=8,
        llm_model="glm-4.7",
        llm_provider="zai",
        prompt="Verify monster/AI/daemon port.\n\nRun: cd demo/rogue/rogue-wasm && cargo build --lib 2>&1\n\nCompare against C source:\n1. Confirm all 26 monster stat entries match monsters.c exactly\n2. Confirm chase/do_chase AI matches chase.c algorithm\n3. Confirm daemon scheduling (start/kill/do_daemons) matches daemon.c\n4. Confirm hunger system timing constants match daemons.c (HUNGERTIME=1300, MORETIME=150, etc.)\n5. Confirm HP regeneration formula matches doctor() in daemons.c\n\nWrite results to .ai/verify_monsters.md.\nWrite status.json: outcome=success if compiles and faithful, outcome=fail with discrepancies."
    ]

    check_monsters [shape=diamond, label="Monsters OK?"]

    // --- Branch D: Player Systems, I/O & State (kimi) ---

    impl_player_io [
        shape=box,
        class="hard",
        max_agent_turns=25,
        max_retries=2,
        llm_model="kimi-k2.5",
        llm_provider="kimi",
        prompt="Goal: $goal\n\nYou are porting the player, I/O, and state management systems from C to Rust.\n\nRead these C source files carefully:\n- demo/rogue/original-rogue/move.c (player movement, running, door handling)\n- demo/rogue/original-rogue/command.c (command dispatch, 50+ key bindings)\n- demo/rogue/original-rogue/pack.c (inventory management, add/remove items)\n- demo/rogue/original-rogue/io.c (message system, addmsg/endmsg/msg, status line)\n- demo/rogue/original-rogue/list.c (linked list ops: attach, detach, free_list)\n- demo/rogue/original-rogue/save.c (save/load game)\n- demo/rogue/original-rogue/state.c (game state serialization, rs_save_file/rs_restore_file)\n- demo/rogue/original-rogue/init.c (game initialization, colors, names, stones)\n- demo/rogue/original-rogue/options.c (game options: name, fruit, terse, jump, etc.)\n- demo/rogue/original-rogue/rip.c (death screen, tombstone ASCII art, scoring)\n- demo/rogue/original-rogue/wizard.c (wizard mode commands)\n- demo/rogue/original-rogue/misc.c (look(), search(), help(), d_level(), u_level(), etc.)\n- demo/rogue/original-rogue/rogue.h\n\nRead the Rust project:\n- demo/rogue/rogue-wasm/src/types.rs\n- demo/rogue/rogue-wasm/src/game.rs\n- demo/rogue/rogue-wasm/.ai/rogue_architecture.md\n\nImplement:\n\n**demo/rogue/rogue-wasm/src/player.rs:**\n- command() — the main command dispatch (50+ key bindings: h/j/k/l movement, H/J/K/L running, y/u/b/n diagonal, e eat, q quaff, r read, w wield, W wear, T take off, P put on ring, R remove ring, d drop, c call, D discovered, i inventory, s search, z zap, t throw, > stairs down, < stairs up, . wait, etc.)\n- do_move() — execute player movement in direction\n- do_run() — start running in direction\n- look() — update visibility around player, handle room enter/leave\n- enter_room() / leave_room() — room transition logic with lighting\n- erase_lamp() — erase light around player position\n- search() — search for traps/secret doors\n- be_trapped() — trigger trap effects\n- door_open() — open a door\n- teleport() — random teleportation\n- d_level() / u_level() — go down/up stairs\n- shell() — no-op in WASM (was shell escape)\n- help() — display help text\n- show_map() — reveal full map (wizard)\n- show_win() — show a text window\n- status() — update status line\n- waste_time() — do nothing for a turn\n- illcom() — illegal command message\n\n**demo/rogue/rogue-wasm/src/io_bridge.rs:**\n- msg() / addmsg() / endmsg() — message buffering system\n- status() — format status line (Level, Hits, Str, Gold, Armor, Exp)\n- wait_for() — wait for specific key (becomes async in WASM)\n- readchar() — read a character (from JS key queue in WASM)\n- Message buffer management\n- The message line is row 0, status line is row 23\n\n**demo/rogue/rogue-wasm/src/state.rs:**\n- save_game() — serialize entire GameState\n- restore() — deserialize GameState\n- For WASM: use serde + localStorage instead of file I/O\n- Must serialize: all rooms, all monsters, all items, player state, dungeon map, daemon list, RNG state, all game flags\n\n**demo/rogue/rogue-wasm/src/init.rs:**\n- init_player() — starting stats (STR 16, HP 12, etc.)\n- init_colors() — randomize potion colors\n- init_stones() — randomize ring stones\n- init_materials() — randomize wand materials\n- init_names() — randomize scroll names\n- init_probs() — initialize probability tables\n- parse_opts() — parse game options\n- option() — options menu\n\n**demo/rogue/rogue-wasm/src/score.rs:**\n- death() — handle player death\n- score() — display/update scoreboard\n- total_winner() — amulet victory sequence\n- tombstone ASCII art from rip.c\n- For WASM: scores stored in localStorage\n\n**demo/rogue/rogue-wasm/src/wizard.rs:**\n- Wizard mode commands: create_obj(), show_map(), teleport(), etc.\n- passwd() — wizard password check\n\n**List operations** — replace C linked lists with Vec<Thing> methods on GameState:\n- attach/detach -> push/remove on Vec\n- free_list -> clear Vec\n\nThe port must be EXACT — same command bindings, same status line format, same tombstone ASCII art.\n\nRun: cd demo/rogue/rogue-wasm && cargo build --lib 2>&1\n\nWrite implementation log to .ai/port_player_io.md.\nWrite status.json: outcome=success if compiles, outcome=fail with errors."
    ]

    verify_player_io [
        shape=box,
        class="verify",
        max_agent_turns=8,
        llm_model="kimi-k2.5",
        llm_provider="kimi",
        prompt="Verify player/IO/state port.\n\nRun: cd demo/rogue/rogue-wasm && cargo build --lib 2>&1\n\nCompare against C source:\n1. Confirm command() dispatches all keys from command.c\n2. Confirm do_move() matches move.c movement logic\n3. Confirm message system matches io.c (msg/addmsg/endmsg)\n4. Confirm status line format matches (Level: X Hits: X(X) Str: X Gold: X Armor: X Exp: X/X)\n5. Confirm tombstone ASCII art matches rip.c\n6. Confirm init_player() starting stats match init.c\n7. Confirm save/restore serializes all game state\n\nWrite results to .ai/verify_player_io.md.\nWrite status.json: outcome=success if compiles and faithful, outcome=fail with discrepancies."
    ]

    check_player_io [shape=diamond, label="Player/IO OK?"]

    // Fan-in: wait for all branches
    fanin [shape=tripleoctagon, label="Fan In: Merge Ports"]

    // =========================================================================
    // Phase 6: Integration — wire everything together
    // =========================================================================

    impl_integration [
        shape=box,
        class="hard",
        max_agent_turns=25,
        max_retries=2,
        prompt="Goal: $goal\n\nAll four system ports are complete. Now integrate them into a working game.\n\nRead:\n- .ai/rogue_architecture.md (the target architecture)\n- .ai/port_dungeon.md, .ai/port_combat_items.md, .ai/port_monsters.md, .ai/port_player_io.md (what was implemented)\n- All source files in demo/rogue/rogue-wasm/src/\n\nIntegration tasks:\n\n1. **Wire the main game loop** in src/game.rs:\n   - new_game(seed): init RNG, init_player, init_colors/stones/materials/names/probs, new_level, start daemons (runners, doctor, stomach, swander)\n   - process_key(key): parse key -> command dispatch -> execute action -> do_daemons(BEFORE) -> do_fuses(BEFORE) -> monster turns -> do_daemons(AFTER) -> do_fuses(AFTER) -> update screen buffer -> return FrameUpdate\n   - Match the exact turn order from main.c/command.c\n\n2. **Fix cross-module references**:\n   - Ensure dungeon.rs functions can call monsters.rs (new_monster in new_level)\n   - Ensure combat.rs can call items.rs (drop loot on kill)\n   - Ensure player.rs can call all other modules (command dispatch)\n   - Ensure daemon callbacks reference the correct functions\n   - Resolve any borrow checker issues with GameState access\n\n3. **Implement the WASM bridge** in src/lib.rs:\n   - #[wasm_bindgen] Game struct wrapping GameState\n   - new_game(seed) -> Game\n   - process_key(key: &str) -> JsValue containing screen state\n   - get_screen_json() -> String (JSON array of {ch, fg, bg} for each cell)\n   - get_message() -> String\n   - get_status() -> String\n\n4. **Build the HTML/JS frontend** in www/index.html:\n   - Import WASM module\n   - Create 80x24 grid of <span> elements\n   - Map keyboard events to process_key() calls\n   - Render returned screen state to the grid\n   - Handle game-over state\n   - Add visual styling: monospace font, dark background, color support\n   - Input: arrow keys -> hjkl mapping, plus all direct key inputs\n\n5. **Fix compilation errors** — resolve all type mismatches, missing imports, borrow issues.\n\nRun:\n  cd demo/rogue/rogue-wasm && cargo build --lib 2>&1\n  cd demo/rogue/rogue-wasm && wasm-pack build --target web 2>&1\n\nBoth MUST succeed.\n\nWrite integration log to .ai/integration_log.md.\nWrite status.json: outcome=success if wasm-pack build succeeds, outcome=fail with errors."
    ]

    verify_integration [
        shape=box,
        class="verify",
        max_agent_turns=10,
        prompt="Verify full integration.\n\nRun:\n1. cd demo/rogue/rogue-wasm && cargo build --lib 2>&1\n2. cd demo/rogue/rogue-wasm && wasm-pack build --target web 2>&1\n3. Check that pkg/ directory was created with .wasm and .js files\n4. Check www/index.html imports the WASM module correctly\n5. Check that Game struct exports new_game and process_key via wasm_bindgen\n6. Verify the game loop in game.rs follows the correct turn order from main.c\n\nWrite results to .ai/verify_integration.md.\nWrite status.json: outcome=success if all pass, outcome=fail with details."
    ]

    check_integration [shape=diamond, label="Integration OK?"]

    // =========================================================================
    // Phase 7: Final review
    // =========================================================================

    review [
        shape=box,
        class="review",
        goal_gate=true,
        max_agent_turns=20,
        prompt="Goal: $goal\n\nFinal review of the complete Rogue C-to-Rust/WASM port.\n\nRead:\n- .ai/spec.md (requirements)\n- .ai/rogue_analysis.md (C source analysis)\n- .ai/rogue_architecture.md (target architecture)\n- All source files in demo/rogue/rogue-wasm/src/\n- demo/rogue/rogue-wasm/www/index.html\n\nReview checklist:\n\n1. **Completeness**: Every C source file has been ported. Cross-reference against the analysis — are any functions missing?\n2. **Fidelity**: Spot-check 10 critical algorithms against the C source:\n   a. RNG formula (seed*11109+13849 >> 16)\n   b. Room generation (3x3 grid, size randomization)\n   c. Monster stats table (all 26 entries)\n   d. Combat roll_em() dice parsing\n   e. Hunger system timing (HUNGERTIME=1300)\n   f. HP regeneration formula\n   g. Potion effect for P_HASTE (add_haste)\n   h. Scroll effect for S_TELEP (teleport)\n   i. Trap effects (T_ARROW damage)\n   j. Level-up XP thresholds (e_levels table)\n3. **WASM bridge**: Is the API sufficient for full gameplay?\n4. **HTML frontend**: Does it render 80x24 grid with proper styling?\n5. **Build**: Run `cd demo/rogue/rogue-wasm && wasm-pack build --target web 2>&1` — must succeed.\n6. **Save/Load**: Is game state fully serializable?\n7. **Missing features**: wizard mode, options menu, scoring — all present?\n\nIf issues found, document them clearly with file:line references.\n\nWrite review to .ai/final_review.md.\nWrite status.json: outcome=success if the port is complete and faithful, outcome=fail with specific issues to fix."
    ]

    check_review [shape=diamond, label="Review OK?"]

    // =========================================================================
    // Edges
    // =========================================================================

    // Phase 1-2: Spec and analysis
    start -> check_toolchain
    check_toolchain -> expand_spec [condition="outcome=success"]
    expand_spec -> impl_analysis
    impl_analysis -> verify_analysis -> check_analysis
    check_analysis -> impl_architecture     [condition="outcome=success"]
    check_analysis -> impl_analysis         [condition="outcome=fail", label="retry"]

    // Phase 3: Architecture
    impl_architecture -> verify_architecture -> check_architecture
    check_architecture -> impl_scaffold     [condition="outcome=success"]
    check_architecture -> impl_architecture [condition="outcome=fail", label="retry"]

    // Phase 4: Scaffold
    impl_scaffold -> verify_scaffold -> check_scaffold
    check_scaffold -> fanout                [condition="outcome=success"]
    check_scaffold -> impl_scaffold         [condition="outcome=fail", label="retry"]

    // Phase 5: Parallel fanout
    fanout -> impl_dungeon
    fanout -> impl_combat_items
    fanout -> impl_monsters
    fanout -> impl_player_io

    // Branch A
    impl_dungeon -> verify_dungeon -> check_dungeon
    check_dungeon -> fanin                  [condition="outcome=success"]
    check_dungeon -> impl_dungeon           [condition="outcome=fail", label="retry"]

    // Branch B
    impl_combat_items -> verify_combat_items -> check_combat_items
    check_combat_items -> fanin             [condition="outcome=success"]
    check_combat_items -> impl_combat_items [condition="outcome=fail", label="retry"]

    // Branch C
    impl_monsters -> verify_monsters -> check_monsters
    check_monsters -> fanin                 [condition="outcome=success"]
    check_monsters -> impl_monsters         [condition="outcome=fail", label="retry"]

    // Branch D
    impl_player_io -> verify_player_io -> check_player_io
    check_player_io -> fanin                [condition="outcome=success"]
    check_player_io -> impl_player_io       [condition="outcome=fail", label="retry"]

    // Phase 6: Integration
    fanin -> impl_integration
    impl_integration -> verify_integration -> check_integration
    check_integration -> review             [condition="outcome=success"]
    check_integration -> impl_integration   [condition="outcome=fail", label="retry"]

    // Phase 7: Review
    review -> check_review
    check_review -> exit                    [condition="outcome=success"]
    check_review -> impl_integration        [condition="outcome=fail", label="fix"]
}

digraph rogue_wasm_port {
    graph [
        goal="Port Rogue 5.4.4 from C to Rust/WebAssembly, playable in a browser as a single HTML page with faithful 1:1 translation of every game system",
        rankdir=LR,
        default_max_retry=3,
        retry_target="check_dod",
        fallback_retry_target="implement",
        provenance_version="1",
        provenance_file="path=demo/rogue/rogue-prompt.txt;git_sha=18857c6a2d1e83c987906695b06b254afa2c1d96",
        model_stylesheet="
            * { llm_model: kimi-k2.5; llm_provider: kimi; }
            .hard { llm_model: kimi-k2.5; llm_provider: kimi; }
            .verify { llm_model: kimi-k2.5; llm_provider: kimi; }
            .review { llm_model: kimi-k2.5; llm_provider: kimi; }
        "
    ]

    start [shape=Mdiamond, label="Start"]
    exit  [shape=Msquare, label="Exit"]

    // =========================================================================
    // Toolchain readiness gate — fail fast before expensive LLM stages
    // =========================================================================
    check_toolchain [
        shape=parallelogram,
        max_retries=0,
        tool_command="bash -lc 'set -euo pipefail; command -v cargo >/dev/null || { echo \"missing required tool: cargo — install via https://rustup.rs\" >&2; exit 1; }; command -v wasm-pack >/dev/null || { echo \"missing required tool: wasm-pack — install via: cargo install wasm-pack\" >&2; exit 1; }; rustup target list --installed | grep -qx wasm32-unknown-unknown || { echo \"missing rustup target: wasm32-unknown-unknown — install via: rustup target add wasm32-unknown-unknown\" >&2; exit 1; }; echo \"toolchain OK: cargo, wasm-pack, wasm32-unknown-unknown target all present\"'"
    ]

    // =========================================================================
    // Spec expansion — the prompt file exists but we need a full structured spec
    // =========================================================================
    expand_spec [
        shape=box,
        auto_status=true,
        prompt="Goal: $goal\n\nYou are porting the classic Rogue 5.4.4 game from C to Rust compiled to WebAssembly. The original C source is at demo/rogue/original-rogue/ (about 16,800 lines across 33 files).\n\nRead demo/rogue/rogue-prompt.txt for the high-level requirements.\n\nRead the original C source files in demo/rogue/original-rogue/ to understand the full scope. Key files:\n- main.c, command.c, io.c — game loop and I/O\n- new_level.c, passages.c, rooms.c — dungeon generation\n- monsters.c, chase.c, fight.c — monster AI and combat\n- pack.c, potions.c, scrolls.c, sticks.c, rings.c, weapons.c, armor.c — items\n- rogue.h, extern.h, extern.c — types, globals, constants\n- daemon.c, daemons.c — timed effects\n- save.c, mach_dep.c — save/load and platform\n- things.c, list.c, misc.c, move.c, options.c, wizard.c — utilities\n\nExpand into a detailed spec covering:\n1. Project structure: Rust crate layout under demo/rogue/rogue-wasm/\n2. Module mapping: which C files map to which Rust modules\n3. Type system: key structs (THING, room, object, coord, etc.) and their Rust equivalents\n4. Global state management strategy (Rust does not allow C-style globals)\n5. Dungeon generation algorithm (exact port of new_level.c + passages.c)\n6. Monster system: stats table, AI (chase.c), spawn rules\n7. Combat system: exact formulas from fight.c\n8. Item system: potions, scrolls, sticks, rings, weapons, armor — all tables and effects\n9. RNG: exact port of the seed/random formula\n10. WASM bridge: replacing ncurses with JS terminal renderer\n11. Save/load: localStorage strategy replacing filesystem\n12. HTML deliverable: single page at demo/rogue/rogue-wasm/www/index.html\n13. Build pipeline: wasm-pack commands, output structure\n14. Acceptance criteria and Definition of Done\n\nWrite the spec to .ai/spec.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path), fallback to $KILROY_STAGE_STATUS_FALLBACK_PATH, and do not write nested status.json files.\nWrite status JSON: outcome=success"
    ]

    // =========================================================================
    // Phase: Check if Definition of Done exists or needs generation
    // =========================================================================
    check_dod [
        shape=diamond,
        label="DoD exists?",
        prompt="Check if a definition of done has been established for this project.\n\nRead .ai/spec.md and check if it contains a clear, comprehensive Definition of Done section with measurable acceptance criteria.\n\nAlso check if .ai/definition_of_done.md exists.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path), fallback to $KILROY_STAGE_STATUS_FALLBACK_PATH, and do not write nested status.json files.\nWrite status JSON: outcome=has_dod if a substantive DoD exists (either in spec.md or definition_of_done.md), outcome=needs_dod if no DoD or only placeholder text."
    ]

    // =========================================================================
    // DoD fan-out: 3 independent proposals
    // =========================================================================
    define_dod_a [
        shape=box,
        prompt="Goal: $goal\n\nPropose a Definition of Done for porting Rogue 5.4.4 from C to Rust/WASM.\n\nRead .ai/spec.md and the original C source in demo/rogue/original-rogue/ (especially rogue.h for types and constants, fight.c for combat, new_level.c for dungeon gen, monsters.c for monster tables).\n\nYour DoD must include measurable, verifiable criteria covering:\n- Build: cargo build --target wasm32-unknown-unknown succeeds, wasm-pack build produces pkg/\n- Completeness: every C source file has a corresponding Rust module with equivalent logic\n- Fidelity: dungeon generation, combat math, RNG, monster AI, item effects all match C originals\n- Rendering: 80x24 ASCII grid, @ player, # corridors, A-Z monsters, dark background, monospace font\n- Playability: game loop works in browser — movement, combat, items, stairs, death, win condition\n- Save/load: localStorage-based save and restore\n- Deliverable: single HTML page at demo/rogue/rogue-wasm/www/index.html\n\nWrite your DoD proposal to .ai/dod_a.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path), fallback to $KILROY_STAGE_STATUS_FALLBACK_PATH, and do not write nested status.json files.\nWrite status JSON: outcome=success"
    ]

    define_dod_b [
        shape=box,
        prompt="Goal: $goal\n\nPropose a Definition of Done for porting Rogue 5.4.4 from C to Rust/WASM.\n\nRead .ai/spec.md and the original C source in demo/rogue/original-rogue/ (especially rogue.h for types and constants, fight.c for combat, new_level.c for dungeon gen, monsters.c for monster tables).\n\nYour DoD must include measurable, verifiable criteria covering:\n- Build: cargo build --target wasm32-unknown-unknown succeeds, wasm-pack build produces pkg/\n- Completeness: every C source file has a corresponding Rust module with equivalent logic\n- Fidelity: dungeon generation, combat math, RNG, monster AI, item effects all match C originals\n- Rendering: 80x24 ASCII grid, @ player, # corridors, A-Z monsters, dark background, monospace font\n- Playability: game loop works in browser — movement, combat, items, stairs, death, win condition\n- Save/load: localStorage-based save and restore\n- Deliverable: single HTML page at demo/rogue/rogue-wasm/www/index.html\n\nWrite your DoD proposal to .ai/dod_b.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path), fallback to $KILROY_STAGE_STATUS_FALLBACK_PATH, and do not write nested status.json files.\nWrite status JSON: outcome=success"
    ]

    define_dod_c [
        shape=box,
        prompt="Goal: $goal\n\nPropose a Definition of Done for porting Rogue 5.4.4 from C to Rust/WASM.\n\nRead .ai/spec.md and the original C source in demo/rogue/original-rogue/ (especially rogue.h for types and constants, fight.c for combat, new_level.c for dungeon gen, monsters.c for monster tables).\n\nYour DoD must include measurable, verifiable criteria covering:\n- Build: cargo build --target wasm32-unknown-unknown succeeds, wasm-pack build produces pkg/\n- Completeness: every C source file has a corresponding Rust module with equivalent logic\n- Fidelity: dungeon generation, combat math, RNG, monster AI, item effects all match C originals\n- Rendering: 80x24 ASCII grid, @ player, # corridors, A-Z monsters, dark background, monospace font\n- Playability: game loop works in browser — movement, combat, items, stairs, death, win condition\n- Save/load: localStorage-based save and restore\n- Deliverable: single HTML page at demo/rogue/rogue-wasm/www/index.html\n\nWrite your DoD proposal to .ai/dod_c.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path), fallback to $KILROY_STAGE_STATUS_FALLBACK_PATH, and do not write nested status.json files.\nWrite status JSON: outcome=success"
    ]

    // =========================================================================
    // Consolidate DoD proposals into a single consensus DoD
    // =========================================================================
    consolidate_dod [
        shape=box,
        prompt="Goal: $goal\n\nSynthesize three Definition of Done proposals into a single consensus DoD.\n\nRead .ai/dod_a.md, .ai/dod_b.md, .ai/dod_c.md.\n\nProduce a unified, non-redundant DoD that takes the strongest and most measurable criteria from each proposal. Organize by category (build, completeness, fidelity, rendering, playability, save/load, deliverable).\n\nWrite the consensus DoD to .ai/definition_of_done.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path), fallback to $KILROY_STAGE_STATUS_FALLBACK_PATH, and do not write nested status.json files.\nWrite status JSON: outcome=success when synthesis is complete, outcome=fail with failure_reason and details otherwise."
    ]

    // =========================================================================
    // Planning fan-out: 3 independent implementation plans
    // =========================================================================
    plan_a [
        shape=box,
        prompt="Goal: $goal\n\nCreate a detailed implementation plan for porting Rogue 5.4.4 from C to Rust/WASM.\n\nRead:\n- .ai/spec.md (project spec)\n- .ai/definition_of_done.md (acceptance criteria)\n- demo/rogue/original-rogue/rogue.h (core types and constants)\n- demo/rogue/original-rogue/extern.h and extern.c (globals)\n- demo/rogue/original-rogue/main.c (game loop)\n- demo/rogue/original-rogue/new_level.c (dungeon generation)\n- demo/rogue/original-rogue/fight.c (combat)\n- demo/rogue/original-rogue/monsters.c (monster tables)\n\nIf .ai/postmortem_latest.md exists, read it and incorporate its lessons — focus on what specifically failed or was incomplete in the previous attempt and how to address those gaps.\n\nYour plan must cover:\n1. Crate structure and Cargo.toml setup (lib target for wasm-pack)\n2. Rust type definitions matching C structs (THING, room, object, coord, etc.)\n3. Global state management (single GameState struct or similar)\n4. Module-by-module porting order with dependencies\n5. WASM bridge layer (replacing ncurses)\n6. JavaScript terminal renderer (80x24 canvas/DOM grid)\n7. HTML shell page\n8. Build commands (wasm-pack build, wasm-opt)\n9. Testing strategy\n10. Progressive compilation checkpoints\n\nWrite your plan to .ai/plan_a.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path), fallback to $KILROY_STAGE_STATUS_FALLBACK_PATH, and do not write nested status.json files.\nWrite status JSON: outcome=success when the plan is complete, outcome=fail with failure_reason and details otherwise."
    ]

    plan_b [
        shape=box,
        prompt="Goal: $goal\n\nCreate a detailed implementation plan for porting Rogue 5.4.4 from C to Rust/WASM.\n\nRead:\n- .ai/spec.md (project spec)\n- .ai/definition_of_done.md (acceptance criteria)\n- demo/rogue/original-rogue/rogue.h (core types and constants)\n- demo/rogue/original-rogue/extern.h and extern.c (globals)\n- demo/rogue/original-rogue/main.c (game loop)\n- demo/rogue/original-rogue/new_level.c (dungeon generation)\n- demo/rogue/original-rogue/fight.c (combat)\n- demo/rogue/original-rogue/monsters.c (monster tables)\n\nIf .ai/postmortem_latest.md exists, read it and incorporate its lessons — focus on what specifically failed or was incomplete in the previous attempt and how to address those gaps.\n\nYour plan must cover:\n1. Crate structure and Cargo.toml setup (lib target for wasm-pack)\n2. Rust type definitions matching C structs (THING, room, object, coord, etc.)\n3. Global state management (single GameState struct or similar)\n4. Module-by-module porting order with dependencies\n5. WASM bridge layer (replacing ncurses)\n6. JavaScript terminal renderer (80x24 canvas/DOM grid)\n7. HTML shell page\n8. Build commands (wasm-pack build, wasm-opt)\n9. Testing strategy\n10. Progressive compilation checkpoints\n\nWrite your plan to .ai/plan_b.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path), fallback to $KILROY_STAGE_STATUS_FALLBACK_PATH, and do not write nested status.json files.\nWrite status JSON: outcome=success when the plan is complete, outcome=fail with failure_reason and details otherwise."
    ]

    plan_c [
        shape=box,
        prompt="Goal: $goal\n\nCreate a detailed implementation plan for porting Rogue 5.4.4 from C to Rust/WASM.\n\nRead:\n- .ai/spec.md (project spec)\n- .ai/definition_of_done.md (acceptance criteria)\n- demo/rogue/original-rogue/rogue.h (core types and constants)\n- demo/rogue/original-rogue/extern.h and extern.c (globals)\n- demo/rogue/original-rogue/main.c (game loop)\n- demo/rogue/original-rogue/new_level.c (dungeon generation)\n- demo/rogue/original-rogue/fight.c (combat)\n- demo/rogue/original-rogue/monsters.c (monster tables)\n\nIf .ai/postmortem_latest.md exists, read it and incorporate its lessons — focus on what specifically failed or was incomplete in the previous attempt and how to address those gaps.\n\nYour plan must cover:\n1. Crate structure and Cargo.toml setup (lib target for wasm-pack)\n2. Rust type definitions matching C structs (THING, room, object, coord, etc.)\n3. Global state management (single GameState struct or similar)\n4. Module-by-module porting order with dependencies\n5. WASM bridge layer (replacing ncurses)\n6. JavaScript terminal renderer (80x24 canvas/DOM grid)\n7. HTML shell page\n8. Build commands (wasm-pack build, wasm-opt)\n9. Testing strategy\n10. Progressive compilation checkpoints\n\nWrite your plan to .ai/plan_c.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path), fallback to $KILROY_STAGE_STATUS_FALLBACK_PATH, and do not write nested status.json files.\nWrite status JSON: outcome=success when the plan is complete, outcome=fail with failure_reason and details otherwise."
    ]

    // =========================================================================
    // Debate and consolidate plans into a single final plan
    // =========================================================================
    debate_consolidate [
        shape=box,
        prompt="Goal: $goal\n\nSynthesize three implementation plans into a single best-of-breed final plan.\n\nRead .ai/plan_a.md, .ai/plan_b.md, .ai/plan_c.md.\nAlso read .ai/definition_of_done.md for acceptance criteria.\n\nFor each section, compare the three plans and select or merge the strongest approach. Resolve any conflicts. The final plan must be:\n- Concrete: specific file paths, module names, function signatures\n- Ordered: clear dependency chain for progressive compilation\n- Complete: covers all C source files and all game systems\n- Buildable: every checkpoint must compile with cargo build --target wasm32-unknown-unknown\n\nIf .ai/postmortem_latest.md exists, ensure the final plan explicitly addresses every issue raised in the postmortem.\n\nWrite the consolidated final plan to .ai/plan_final.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path), fallback to $KILROY_STAGE_STATUS_FALLBACK_PATH, and do not write nested status.json files.\nWrite status JSON: outcome=success when synthesis is complete, outcome=fail with failure_reason and details otherwise."
    ]

    // =========================================================================
    // Single-writer implementation — the core build node
    // =========================================================================
    implement [
        shape=box,
        class="hard",
        allow_partial=true,
        max_retries=2,
        prompt="Goal: $goal\n\nExecute the implementation plan to port Rogue 5.4.4 from C to Rust/WebAssembly.\n\nRead:\n- .ai/plan_final.md (the consolidated implementation plan)\n- .ai/definition_of_done.md (acceptance criteria)\n- .ai/spec.md (project spec)\n- The original C source files in demo/rogue/original-rogue/ as needed during porting\n\nIf .ai/postmortem_latest.md exists, read it and prioritize fixing the specific issues identified there.\n\nImplementation approach — progressive compilation:\n1. FIRST MILESTONE: Create Cargo.toml (lib crate with cdylib target for wasm-pack), src/lib.rs with wasm_bindgen entry points, and all module files with stub implementations. Verify: cargo build --target wasm32-unknown-unknown must pass.\n2. Port core types and constants from rogue.h: coord, THING, room, object, monster stats tables. Verify: cargo build --target wasm32-unknown-unknown must pass.\n3. Port RNG (exact formula from rogue.h/misc.c). Verify: cargo build must pass.\n4. Port dungeon generation (new_level.c, passages.c, rooms.c). Verify: cargo build must pass.\n5. Port monster system (monsters.c, chase.c). Verify: cargo build must pass.\n6. Port combat system (fight.c) with exact damage formulas. Verify: cargo build must pass.\n7. Port item systems: pack.c, potions.c, scrolls.c, sticks.c, rings.c, weapons.c, armor.c. Verify: cargo build must pass.\n8. Port daemon/timer system (daemon.c, daemons.c). Verify: cargo build must pass.\n9. Port game loop, commands, movement (main.c, command.c, move.c). Verify: cargo build must pass.\n10. Port save/load using serde + localStorage bridge. Verify: cargo build must pass.\n11. Implement WASM bridge (replacing ncurses io.c): wasm_bindgen exports for init, tick/input, get_display_buffer. Verify: wasm-pack build --target web must pass.\n12. Create JavaScript terminal renderer: 80x24 grid, monospace font, dark background, keyboard input handling.\n13. Create demo/rogue/rogue-wasm/www/index.html that loads the WASM module and renders the game.\n\nDo NOT proceed to the next module until the current one compiles.\nIf you spend more than a third of your turns on build errors without reaching a clean compile, simplify: comment out broken code, add stubs, get to green, then iterate.\n\nLog progress and decisions to .ai/implementation_log.md.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path), fallback to $KILROY_STAGE_STATUS_FALLBACK_PATH, and do not write nested status.json files.\nWrite status JSON: outcome=success if wasm-pack build --target web succeeds and www/index.html exists, outcome=fail with failure_reason and details otherwise."
    ]

    // =========================================================================
    // Review fan-out: 3 independent reviewers
    // =========================================================================
    review_a [
        shape=box,
        class="review",
        prompt="Goal: $goal\n\nReview the Rogue 5.4.4 C-to-Rust/WASM port for correctness and completeness.\n\nRead:\n- .ai/spec.md (project spec)\n- .ai/definition_of_done.md (acceptance criteria)\n- .ai/plan_final.md (implementation plan)\n- .ai/implementation_log.md (what was done)\n- The Rust source files under demo/rogue/rogue-wasm/src/\n- The original C source files in demo/rogue/original-rogue/ for comparison\n- demo/rogue/rogue-wasm/www/index.html\n\nReview criteria:\n1. BUILD: Does `cd demo/rogue/rogue-wasm && wasm-pack build --target web` succeed?\n2. COMPLETENESS: Is every C source file represented by a corresponding Rust module?\n3. FIDELITY: Spot-check at least 5 critical algorithms against the C originals:\n   - Dungeon generation (new_level.c room placement and corridor digging)\n   - Combat math (fight.c roll_em, check_level)\n   - Monster stats table (monsters.c)\n   - RNG formula\n   - At least one item effect (potions.c or scrolls.c)\n4. TYPES: Do Rust types faithfully represent C structs (THING, room, object, coord)?\n5. WASM BRIDGE: Are wasm_bindgen exports correct? Does the JS renderer handle 80x24 grid?\n6. HTML: Does www/index.html exist and load the WASM module correctly?\n7. SAVE/LOAD: Is localStorage-based save/load implemented?\n\nWrite your review to .ai/review_a.md with a clear PASS or FAIL verdict and specific issues found.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path), fallback to $KILROY_STAGE_STATUS_FALLBACK_PATH, and do not write nested status.json files.\nWrite status JSON: outcome=pass if the port meets the DoD, outcome=fail with failure_reason and details listing specific gaps."
    ]

    review_b [
        shape=box,
        class="review",
        prompt="Goal: $goal\n\nReview the Rogue 5.4.4 C-to-Rust/WASM port for correctness and completeness.\n\nRead:\n- .ai/spec.md (project spec)\n- .ai/definition_of_done.md (acceptance criteria)\n- .ai/plan_final.md (implementation plan)\n- .ai/implementation_log.md (what was done)\n- The Rust source files under demo/rogue/rogue-wasm/src/\n- The original C source files in demo/rogue/original-rogue/ for comparison\n- demo/rogue/rogue-wasm/www/index.html\n\nReview criteria:\n1. BUILD: Does `cd demo/rogue/rogue-wasm && wasm-pack build --target web` succeed?\n2. COMPLETENESS: Is every C source file represented by a corresponding Rust module?\n3. FIDELITY: Spot-check at least 5 critical algorithms against the C originals:\n   - Dungeon generation (new_level.c room placement and corridor digging)\n   - Combat math (fight.c roll_em, check_level)\n   - Monster stats table (monsters.c)\n   - RNG formula\n   - At least one item effect (potions.c or scrolls.c)\n4. TYPES: Do Rust types faithfully represent C structs (THING, room, object, coord)?\n5. WASM BRIDGE: Are wasm_bindgen exports correct? Does the JS renderer handle 80x24 grid?\n6. HTML: Does www/index.html exist and load the WASM module correctly?\n7. SAVE/LOAD: Is localStorage-based save/load implemented?\n\nWrite your review to .ai/review_b.md with a clear PASS or FAIL verdict and specific issues found.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path), fallback to $KILROY_STAGE_STATUS_FALLBACK_PATH, and do not write nested status.json files.\nWrite status JSON: outcome=pass if the port meets the DoD, outcome=fail with failure_reason and details listing specific gaps."
    ]

    review_c [
        shape=box,
        class="review",
        prompt="Goal: $goal\n\nReview the Rogue 5.4.4 C-to-Rust/WASM port for correctness and completeness.\n\nRead:\n- .ai/spec.md (project spec)\n- .ai/definition_of_done.md (acceptance criteria)\n- .ai/plan_final.md (implementation plan)\n- .ai/implementation_log.md (what was done)\n- The Rust source files under demo/rogue/rogue-wasm/src/\n- The original C source files in demo/rogue/original-rogue/ for comparison\n- demo/rogue/rogue-wasm/www/index.html\n\nReview criteria:\n1. BUILD: Does `cd demo/rogue/rogue-wasm && wasm-pack build --target web` succeed?\n2. COMPLETENESS: Is every C source file represented by a corresponding Rust module?\n3. FIDELITY: Spot-check at least 5 critical algorithms against the C originals:\n   - Dungeon generation (new_level.c room placement and corridor digging)\n   - Combat math (fight.c roll_em, check_level)\n   - Monster stats table (monsters.c)\n   - RNG formula\n   - At least one item effect (potions.c or scrolls.c)\n4. TYPES: Do Rust types faithfully represent C structs (THING, room, object, coord)?\n5. WASM BRIDGE: Are wasm_bindgen exports correct? Does the JS renderer handle 80x24 grid?\n6. HTML: Does www/index.html exist and load the WASM module correctly?\n7. SAVE/LOAD: Is localStorage-based save/load implemented?\n\nWrite your review to .ai/review_c.md with a clear PASS or FAIL verdict and specific issues found.\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path), fallback to $KILROY_STAGE_STATUS_FALLBACK_PATH, and do not write nested status.json files.\nWrite status JSON: outcome=pass if the port meets the DoD, outcome=fail with failure_reason and details listing specific gaps."
    ]

    // =========================================================================
    // Review consensus — synthesize 3 reviews into pass/retry decision
    // =========================================================================
    review_consensus [
        shape=box,
        class="review",
        goal_gate=true,
        prompt="Goal: $goal\n\nReach consensus from three independent reviews of the Rogue 5.4.4 port.\n\nRead .ai/review_a.md, .ai/review_b.md, .ai/review_c.md.\nAlso read .ai/definition_of_done.md for the acceptance criteria.\n\nSynthesize the three reviews:\n- If at least 2 of 3 reviewers gave PASS and no critical issues remain, the consensus is PASS.\n- If 2 or more reviewers gave FAIL, or if any reviewer identified a critical gap (missing game system, build failure, missing HTML page), the consensus is RETRY.\n\nWrite your consensus analysis to .ai/review_consensus.md, listing:\n- Per-reviewer verdict summary\n- Agreed issues (found by multiple reviewers)\n- Unique issues (found by only one reviewer but still valid)\n- Final verdict with reasoning\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path), fallback to $KILROY_STAGE_STATUS_FALLBACK_PATH, and do not write nested status.json files.\nWrite status JSON: outcome=pass if consensus is PASS, outcome=retry with failure_reason and details listing the specific issues to fix."
    ]

    // =========================================================================
    // Postmortem — analyze failure and produce actionable guidance for next loop
    // =========================================================================
    postmortem [
        shape=box,
        prompt="Goal: $goal\n\nConduct a postmortem analysis of the failed implementation attempt.\n\nRead:\n- .ai/review_consensus.md (what the reviewers found wrong)\n- .ai/review_a.md, .ai/review_b.md, .ai/review_c.md (detailed review findings)\n- .ai/implementation_log.md (what was attempted)\n- .ai/plan_final.md (what was planned)\n- .ai/definition_of_done.md (what was required)\n\nIf a previous .ai/postmortem_latest.md exists, read it to understand recurring issues.\n\nProduce an actionable postmortem covering:\n1. ROOT CAUSES: Why did the implementation fail? (e.g., incomplete port, build errors, missing modules, wrong algorithms)\n2. WHAT WORKED: Which parts are solid and should be preserved?\n3. WHAT FAILED: Specific files, modules, or systems that need rework\n4. SPECIFIC FIXES: For each failure, exactly what needs to change (file paths, function names, algorithm corrections)\n5. PRIORITY ORDER: Which fixes to tackle first for maximum progress\n6. ANTI-PATTERNS: What approaches to avoid in the next iteration\n\nIMPORTANT: The next planning iteration must NOT start from scratch. The existing code should be preserved and incrementally improved. Your postmortem must guide targeted fixes, not a complete rewrite.\n\nWrite the postmortem to .ai/postmortem_latest.md (overwriting any previous version).\n\nWrite status JSON to $KILROY_STAGE_STATUS_PATH (absolute path), fallback to $KILROY_STAGE_STATUS_FALLBACK_PATH, and do not write nested status.json files.\nWrite status JSON: outcome=success when postmortem is complete, outcome=fail with failure_reason and details otherwise."
    ]

    // =========================================================================
    // Flow: linear start -> toolchain -> spec -> DoD check
    // =========================================================================
    start -> check_toolchain -> expand_spec -> check_dod

    // DoD branching: if DoD missing, fan out to 3 proposers then consolidate
    check_dod -> define_dod_a [condition="outcome=needs_dod"]
    check_dod -> define_dod_b [condition="outcome=needs_dod"]
    check_dod -> define_dod_c [condition="outcome=needs_dod"]

    define_dod_a -> consolidate_dod
    define_dod_b -> consolidate_dod
    define_dod_c -> consolidate_dod

    // After DoD consolidated, go to planning
    consolidate_dod -> plan_a
    consolidate_dod -> plan_b
    consolidate_dod -> plan_c

    // If DoD already exists, go straight to planning
    check_dod -> plan_a [condition="outcome=has_dod"]
    check_dod -> plan_b [condition="outcome=has_dod"]
    check_dod -> plan_c [condition="outcome=has_dod"]

    // Planning fan-in to debate/consolidate
    plan_a -> debate_consolidate
    plan_b -> debate_consolidate
    plan_c -> debate_consolidate

    // Single-writer implementation
    debate_consolidate -> implement

    // Review fan-out from implementation
    implement -> review_a
    implement -> review_b
    implement -> review_c

    // Review fan-in to consensus
    review_a -> review_consensus
    review_b -> review_consensus
    review_c -> review_consensus

    // Consensus routing: pass -> exit, retry -> postmortem -> loop back to planning
    review_consensus -> exit [condition="outcome=pass"]
    review_consensus -> postmortem

    // Postmortem loops back to planning fan-out (hill-climbing)
    postmortem -> plan_a [loop_restart=true]
    postmortem -> plan_b [loop_restart=true]
    postmortem -> plan_c [loop_restart=true]
}

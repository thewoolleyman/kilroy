digraph rogue_pipeline {
    graph [
        goal="a faithful WebAssembly browser port of Rogue 5.4.4 with a single-page ASCII terminal UI at demo/rogue/rogue-wasm/www/index.html",
        rankdir=LR,
        default_max_retry=3,
        retry_target="implement",
        fallback_retry_target="debate_consolidate",
        provenance_version="1",
        model_stylesheet="
            * { llm_model: minimax-m2.5; llm_provider: minimax; }
            .hard { llm_model: minimax-m2.5; llm_provider: minimax; }
            .verify { llm_model: minimax-m2.5; llm_provider: minimax; }
            .branch-a { llm_model: minimax-m2.5; llm_provider: minimax; }
            .branch-b { llm_model: moonshotai/kimi-k2.5; llm_provider: kimi; }
            .branch-c { llm_model: glm-5; llm_provider: zai; }
        "
    ]

    start [shape=Mdiamond, label="Start"]
    exit [shape=Msquare, label="Exit"]

    check_toolchain [
        shape=parallelogram,
        max_retries=0,
        tool_command="test -d demo/rogue/original-rogue && test -f demo/rogue/spec.md && test -f demo/rogue/DoD.md && command -v cargo >/dev/null && command -v rustc >/dev/null && command -v wasm-pack >/dev/null"
    ]
    check_toolchain_result [shape=diamond, label="Toolchain OK?"]

    seed_spec_and_dod [
        shape=box,
        auto_status=true,
        prompt="Goal: $goal\n\nSeed .ai/spec.md and .ai/definition_of_done.md from the authoritative repo files.\n\nStep 1: Read demo/rogue/spec.md. Copy its content verbatim to .ai/spec.md. Do not summarize, rewrite, or alter the content — copy it exactly.\n\nStep 2: Read demo/rogue/DoD.md. Copy its content verbatim to .ai/definition_of_done.md. Do not summarize, rewrite, or alter the content — copy it exactly.\n\nStep 3: Verify both files were written by reading them back.\n\nThese files are the authoritative specification and Definition of Done for this project. All downstream nodes will read from .ai/spec.md and .ai/definition_of_done.md.\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures.\n\nSet status=success when both .ai/spec.md and .ai/definition_of_done.md are written; otherwise set status=fail."
    ]

    plan_fanout [shape=component, label="Plan Fan-Out"]

    plan_a [
        shape=box,
        class="branch-a",
        prompt="Goal: $goal\n\nCreate an implementation plan.\nRead: .ai/spec.md, .ai/definition_of_done.md.\nAlso read: demo/rogue/original-rogue/rogue.h (constants, structs, macros), demo/rogue/original-rogue/extern.c (monster table, item tables, global data).\nIf .ai/postmortem_latest.md exists, incorporate its lessons.\nWrite: .ai/plan_a.md.\n\nPlan requirements:\n- Single-writer implementation strategy — one implement node writes all code.\n- Phased build: project scaffold and RNG first, then core data types, dungeon gen, items, monsters, combat, commands/IO, wizard mode, save/load, HTML/JS bridge, integration tests.\n- Deterministic verification order: fmt -> build -> test (unit + integration) -> deliverable checks.\n- Preserve exact mechanical fidelity constraints from spec (RNG formula, monster stats, combat math, item tables).\n- Plan must address all 14 acceptance criteria (AC-1 through AC-14) from the DoD.\n- Plan must include writing the 18 unit tests and 11 integration tests listed in the DoD.\n- Reference the original C source files by name for each game system.\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures.\n\nSet status=success when .ai/plan_a.md is written; otherwise status=fail."
    ]

    plan_b [
        shape=box,
        class="branch-b",
        prompt="Goal: $goal\n\nCreate an implementation plan.\nRead: .ai/spec.md, .ai/definition_of_done.md.\nAlso read: demo/rogue/original-rogue/rogue.h (constants, structs, macros), demo/rogue/original-rogue/extern.c (monster table, item tables, global data).\nIf .ai/postmortem_latest.md exists, incorporate its lessons.\nWrite: .ai/plan_b.md.\n\nPlan requirements:\n- Single-writer implementation strategy — one implement node writes all code.\n- Phased build: project scaffold and RNG first, then core data types, dungeon gen, items, monsters, combat, commands/IO, wizard mode, save/load, HTML/JS bridge, integration tests.\n- Deterministic verification order: fmt -> build -> test (unit + integration) -> deliverable checks.\n- Preserve exact mechanical fidelity constraints from spec (RNG formula, monster stats, combat math, item tables).\n- Plan must address all 14 acceptance criteria (AC-1 through AC-14) from the DoD.\n- Plan must include writing the 18 unit tests and 11 integration tests listed in the DoD.\n- Reference the original C source files by name for each game system.\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures.\n\nSet status=success when .ai/plan_b.md is written; otherwise status=fail."
    ]

    plan_c [
        shape=box,
        class="branch-c",
        prompt="Goal: $goal\n\nCreate an implementation plan.\nRead: .ai/spec.md, .ai/definition_of_done.md.\nAlso read: demo/rogue/original-rogue/rogue.h (constants, structs, macros), demo/rogue/original-rogue/extern.c (monster table, item tables, global data).\nIf .ai/postmortem_latest.md exists, incorporate its lessons.\nWrite: .ai/plan_c.md.\n\nPlan requirements:\n- Single-writer implementation strategy — one implement node writes all code.\n- Phased build: project scaffold and RNG first, then core data types, dungeon gen, items, monsters, combat, commands/IO, wizard mode, save/load, HTML/JS bridge, integration tests.\n- Deterministic verification order: fmt -> build -> test (unit + integration) -> deliverable checks.\n- Preserve exact mechanical fidelity constraints from spec (RNG formula, monster stats, combat math, item tables).\n- Plan must address all 14 acceptance criteria (AC-1 through AC-14) from the DoD.\n- Plan must include writing the 18 unit tests and 11 integration tests listed in the DoD.\n- Reference the original C source files by name for each game system.\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures.\n\nSet status=success when .ai/plan_c.md is written; otherwise status=fail."
    ]

    debate_consolidate [
        shape=box,
        prompt="Goal: $goal\n\nCreate the final executable plan.\nRead: .ai/spec.md and .ai/definition_of_done.md.\nRead fanout outputs by first loading $KILROY_LOGS_ROOT/plan_fanout/parallel_results.json and then reading <worktree_dir>/.ai/plan_a.md, <worktree_dir>/.ai/plan_b.md, <worktree_dir>/.ai/plan_c.md from each branch. If parallel_results.json is missing, fall back to .ai/plan_a.md, .ai/plan_b.md, .ai/plan_c.md in the current worktree.\nIf .ai/postmortem_latest.md exists, verify the plan addresses every issue.\nWrite: .ai/plan_final.md.\n\nPlan acceptance checks:\n- Covers all required deliverables including demo/rogue/rogue-wasm/www/index.html.\n- Addresses all 14 DoD acceptance criteria (AC-1 through AC-14).\n- Includes all 18 required unit tests and 11 required integration tests from the DoD.\n- Includes deterministic verification gates before semantic review.\n- Preserves exact-fidelity constraints (RNG, monster stats, combat math, item tables).\n- Includes wizard mode implementation (AC-13) and wizard-assisted gameplay tests (AC-14).\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures.\n\nSet status=success when .ai/plan_final.md is complete; otherwise status=fail."
    ]

    implement [
        shape=box,
        class="hard",
        max_retries=2,
        prompt="Goal: $goal\n\nImplement the Rogue 5.4.4 WASM port using .ai/plan_final.md.\nRead: .ai/spec.md, .ai/definition_of_done.md, .ai/plan_final.md, and .ai/postmortem_latest.md if present.\nRead original C source at demo/rogue/original-rogue/ as the authoritative reference for all game systems.\nWrite: source files under demo/rogue/rogue-wasm/ and .ai/implementation_log.md.\n\nImplementation constraints:\n- Exact mechanical fidelity to Rogue 5.4.4: RNG (seed*11109+13849), all 26 monster stats from extern.c, combat formula (swing/roll_em), item probability tables, dungeon generation algorithm, daemon/fuse system.\n- All game systems including wizard mode (AC-13): create object, level skip, teleport, map reveal, identify, food counter, coordinates, pack count, level objects, see-monsters, infinite charges.\n- Deterministic seed support for reproducible testing.\n- Browser-playable WASM: 80x24 ASCII grid, monospace font, dark background, keyboard input, localStorage save/load.\n- Deliverable page at demo/rogue/rogue-wasm/www/index.html.\n- Write all 18 required unit tests (test_rng_sequence through test_trap_types) per the DoD.\n- Write all 11 required gameplay integration tests (test_gameplay_basic_exploration through test_gameplay_death_and_scoring) per DoD AC-14, using wizard mode as the test harness.\n- Use progressive compilation: get each module compiling before starting the next.\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures.\n\nSet status=success when implementation is ready for checks.\nSet status=fail on deterministic coding/build blockers."
    ]
    check_implement [shape=diamond, label="Implement OK?"]

    verify_fmt [
        shape=parallelogram,
        tool_command="cd demo/rogue/rogue-wasm && cargo fmt --check"
    ]
    check_fmt [shape=diamond, label="Fmt OK?"]

    verify_build [
        shape=parallelogram,
        tool_command="cd demo/rogue/rogue-wasm && cargo build --target wasm32-unknown-unknown"
    ]
    check_build [shape=diamond, label="Build OK?"]

    verify_test [
        shape=parallelogram,
        tool_command="cd demo/rogue/rogue-wasm && cargo test"
    ]
    check_test [shape=diamond, label="Tests OK?"]

    verify_deliverable [
        shape=parallelogram,
        tool_command="test -f demo/rogue/rogue-wasm/www/index.html && grep -qi 'wasm\\|.wasm' demo/rogue/rogue-wasm/www/index.html && grep -qi 'monospace\\|courier\\|mono' demo/rogue/rogue-wasm/www/index.html"
    ]
    check_deliverable [shape=diamond, label="Deliverable OK?"]

    verify_artifacts [
        shape=parallelogram,
        tool_command="if git diff --name-only | grep -qE '(^|/)(target|node_modules|dist|\\.cargo-target|\\.cargo_target)(/|$)'; then echo artifact_paths_detected; exit 1; else exit 0; fi"
    ]
    check_artifacts [shape=diamond, label="Artifacts OK?"]

    verify_fidelity [
        shape=box,
        class="verify",
        prompt="Goal: $goal\n\nPerform semantic fidelity review after all deterministic checks have passed.\nRead: .ai/spec.md, .ai/definition_of_done.md, .ai/implementation_log.md, and the produced Rust source code under demo/rogue/rogue-wasm/src/.\nAlso read the original C source at demo/rogue/original-rogue/ for comparison.\nWrite: .ai/verify_fidelity.md.\n\nVerification checklist — confirm each or flag as a gap:\n1. RNG: Rust implements seed*11109+13849 with upper-16-bit extraction, rnd() and roll() match C exactly.\n2. Monster stats: All 26 monsters (A-Z) have stats matching extern.c (carry%, flags, STR, EXP, LVL, ARM, HP formula, damage string).\n3. Combat: swing() to-hit formula and roll_em() damage formula match C, including str_plus[] and add_dam[] tables.\n4. Items: All type/subtype probability tables match extern.c (14 potions, 18 scrolls, 9 weapons, 8 armors, 14 rings, 14 wands).\n5. Dungeon gen: 3x3 room grid, rdes[] adjacency, spanning tree passages, trap generation formula.\n6. Daemon/fuse: MAXDAEMONS=20, all 4 starting daemons, BEFORE/AFTER ordering.\n7. Hunger: HUNGERTIME=1300, STARVETIME=850, STOMACHSIZE=2000.\n8. Wizard mode: All wizard commands from AC-13 are implemented (C, Ctrl+D/A/T/F/W/E/G/X/~, |, $).\n9. Save/load: Full game state round-trips through localStorage.\n10. Display: 80x24 grid, correct character mappings for all entity types.\n11. Input: All movement, item, meta, and wizard commands handled.\n12. Tests: All 18 unit tests and 11 integration tests exist and cover the scenarios in the DoD.\n13. No placeholder or TODO implementations for any in-scope game system.\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures.\n\nSet status=success if all 13 verification points pass; otherwise set status=fail with specific gaps listed."
    ]
    check_fidelity [shape=diamond, label="Fidelity OK?"]

    review_fanout [shape=component, label="Review Fan-Out"]

    review_a [
        shape=box,
        class="branch-a",
        prompt="Goal: $goal\n\nReview implementation completeness against .ai/definition_of_done.md and .ai/spec.md.\nRead: .ai/spec.md, .ai/definition_of_done.md, .ai/implementation_log.md, .ai/verify_fidelity.md.\nAlso read produced source code under demo/rogue/rogue-wasm/src/ and demo/rogue/rogue-wasm/www/.\nWrite: .ai/review_a.md with APPROVED or REJECTED verdict and concrete evidence.\n\nReview against DoD acceptance criteria:\n- AC-1 (Build/Tooling): cargo build, fmt, test all pass.\n- AC-2 (Deliverable): index.html exists with WASM/monospace references.\n- AC-3 (Display): 80x24 grid, correct character mappings.\n- AC-4 (Input): All movement, item, meta commands.\n- AC-5 (RNG): Exact LCG formula.\n- AC-6 (Dungeon): 3x3 grid, passages, traps.\n- AC-7 (Monsters): All 26 with correct stats and specials.\n- AC-8 (Combat): swing/roll_em formulas.\n- AC-9 (Items): All types with correct probabilities.\n- AC-10 (Daemons): Timing system.\n- AC-11 (Save/Load): localStorage round-trip.\n- AC-12 (Progression): Starting stats, XP levels, amulet.\n- AC-13 (Wizard): All wizard commands.\n- AC-14 (Gameplay Tests): All 11 integration scenarios.\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures.\n\nSet status=success if APPROVED; set status=fail if REJECTED with specific gaps."
    ]

    review_b [
        shape=box,
        class="branch-b",
        prompt="Goal: $goal\n\nReview implementation completeness against .ai/definition_of_done.md and .ai/spec.md.\nRead: .ai/spec.md, .ai/definition_of_done.md, .ai/implementation_log.md, .ai/verify_fidelity.md.\nAlso read produced source code under demo/rogue/rogue-wasm/src/ and demo/rogue/rogue-wasm/www/.\nWrite: .ai/review_b.md with APPROVED or REJECTED verdict and concrete evidence.\n\nReview against DoD acceptance criteria:\n- AC-1 through AC-14 (see .ai/definition_of_done.md for full criteria).\n- Focus on mechanical fidelity: compare Rust constants/formulas against original C source at demo/rogue/original-rogue/.\n- Verify all 18 required unit tests exist and test the right things.\n- Verify all 11 required gameplay integration tests exist and use wizard mode as test harness.\n- Check for TODO/placeholder implementations.\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures.\n\nSet status=success if APPROVED; set status=fail if REJECTED with specific gaps."
    ]

    review_c [
        shape=box,
        class="branch-c",
        prompt="Goal: $goal\n\nReview implementation completeness against .ai/definition_of_done.md and .ai/spec.md.\nRead: .ai/spec.md, .ai/definition_of_done.md, .ai/implementation_log.md, .ai/verify_fidelity.md.\nAlso read produced source code under demo/rogue/rogue-wasm/src/ and demo/rogue/rogue-wasm/www/.\nWrite: .ai/review_c.md with APPROVED or REJECTED verdict and concrete evidence.\n\nReview against DoD acceptance criteria:\n- AC-1 through AC-14 (see .ai/definition_of_done.md for full criteria).\n- Focus on gameplay completeness: can a player explore, fight, use items, descend, die, and win?\n- Verify wizard mode commands all function (AC-13).\n- Verify save/load round-trips correctly (AC-11).\n- Verify hunger/starvation works (AC-10).\n- Check that the HTML deliverable renders correctly (AC-2, AC-3).\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures.\n\nSet status=success if APPROVED; set status=fail if REJECTED with specific gaps."
    ]

    review_consensus [
        shape=box,
        goal_gate=true,
        prompt="Goal: $goal\n\nSynthesize review outcomes into a single consensus.\nRead: .ai/spec.md and .ai/definition_of_done.md.\nRead fanout outputs by first loading $KILROY_LOGS_ROOT/review_fanout/parallel_results.json and then reading <worktree_dir>/.ai/review_a.md, <worktree_dir>/.ai/review_b.md, <worktree_dir>/.ai/review_c.md from each branch. If parallel_results.json is missing, fall back to .ai/review_a.md, .ai/review_b.md, .ai/review_c.md in the current worktree.\nWrite: .ai/review_consensus.md.\n\nConsensus policy:\n- status=success when at least two reviews APPROVED and no critical DoD acceptance criteria gap remains (all AC-1 through AC-14 satisfied).\n- status=retry when specific remediable gaps exist (list them in failure_reason).\n- status=fail only for unrecoverable blocking issues.\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures."
    ]

    postmortem [
        shape=box,
        prompt="Goal: $goal\n\nAnalyze latest failure and define the next repair iteration.\nRead: .ai/review_consensus.md and .ai/implementation_log.md.\nRead: .ai/definition_of_done.md to cross-reference which acceptance criteria failed.\nIf review fanout artifacts are needed, read $KILROY_LOGS_ROOT/review_fanout/parallel_results.json and corresponding <worktree_dir>/.ai/review_a.md, .ai/review_b.md, .ai/review_c.md.\nWrite: .ai/postmortem_latest.md.\n\nOutput must include:\n- Root cause: which specific AC (AC-1 through AC-14) failed and why.\n- What worked: preserve all passing game systems and tests.\n- What failed: specific code/test gaps with file paths.\n- Next changes: concrete repair actions (do not reset successful work).\n- Priority order: fix build-blocking issues first, then test failures, then fidelity gaps.\n\nStatus contract:\n- Write canonical status JSON to $KILROY_STAGE_STATUS_PATH.\n- If unavailable, write the same JSON to $KILROY_STAGE_STATUS_FALLBACK_PATH.\n- Use schema {\"status\":\"...\"}.\n- Do not write nested status.json files after cd.\n- For status=fail or status=retry include failure_reason and details.\n- Include failure_class when classifying deterministic vs transient failures.\n\nSet status=success when .ai/postmortem_latest.md is written."
    ]

    // =========================================================================
    // Flow
    // =========================================================================

    // Bootstrap: toolchain gate -> seed spec+DoD -> planning
    start -> check_toolchain
    check_toolchain -> check_toolchain_result
    check_toolchain_result -> seed_spec_and_dod [condition="outcome=success"]
    check_toolchain_result -> check_toolchain [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_toolchain_result -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_toolchain_result -> postmortem

    seed_spec_and_dod -> plan_fanout

    // Planning fan-out -> debate -> implement
    plan_fanout -> plan_a
    plan_fanout -> plan_b
    plan_fanout -> plan_c
    plan_a -> debate_consolidate
    plan_b -> debate_consolidate
    plan_c -> debate_consolidate
    debate_consolidate -> implement [condition="outcome=success"]
    debate_consolidate -> postmortem [condition="outcome=fail"]
    debate_consolidate -> postmortem

    // Implement -> deterministic verify chain
    implement -> check_implement
    check_implement -> verify_fmt [condition="outcome=success"]
    check_implement -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_implement -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_implement -> postmortem

    verify_fmt -> check_fmt
    check_fmt -> verify_build [condition="outcome=success"]
    check_fmt -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_fmt -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_fmt -> postmortem

    verify_build -> check_build
    check_build -> verify_test [condition="outcome=success"]
    check_build -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_build -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_build -> postmortem

    verify_test -> check_test
    check_test -> verify_deliverable [condition="outcome=success"]
    check_test -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_test -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_test -> postmortem

    verify_deliverable -> check_deliverable
    check_deliverable -> verify_artifacts [condition="outcome=success"]
    check_deliverable -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_deliverable -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_deliverable -> postmortem

    verify_artifacts -> check_artifacts
    check_artifacts -> verify_fidelity [condition="outcome=success"]
    check_artifacts -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_artifacts -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_artifacts -> postmortem

    // Semantic fidelity review -> review fan-out
    verify_fidelity -> check_fidelity
    check_fidelity -> review_fanout [condition="outcome=success"]
    check_fidelity -> implement [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true]
    check_fidelity -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"]
    check_fidelity -> postmortem

    // Review fan-out -> consensus
    review_fanout -> review_a
    review_fanout -> review_b
    review_fanout -> review_c
    review_a -> review_consensus
    review_b -> review_consensus
    review_c -> review_consensus

    // Consensus routing: success -> exit, anything else -> postmortem
    review_consensus -> exit [condition="outcome=success"]
    review_consensus -> postmortem [condition="outcome=retry"]
    review_consensus -> postmortem [condition="outcome=fail"]
    review_consensus -> postmortem

    // Hill-climbing loop: postmortem -> toolchain check -> re-plan -> re-implement
    postmortem -> check_toolchain [loop_restart=true]
}

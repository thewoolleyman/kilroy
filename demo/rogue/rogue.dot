digraph rogue_wasm_port_pipeline {
  graph [
    goal="a faithful browser-playable WebAssembly port of Rogue 5.4.4 from demo/rogue/original-rogue to demo/rogue/rogue-wasm/www/index.html with classic 80x24 ASCII terminal rendering",
    rankdir=LR,
    default_max_retry=3,
    retry_target="implement_port",
    fallback_retry_target="postmortem",
    model_stylesheet="
      * { llm_provider: openai; llm_model: gpt-4.1-mini; }
      .hard { llm_provider: openai; llm_model: gpt-4.1; }
      .verify { llm_provider: openai; llm_model: o4-mini; }
      .review { llm_provider: openai; llm_model: o3; }
    "
  ];

  start [shape=Mdiamond];
  exit [shape=Msquare];

  verify_toolchain [shape=parallelogram, class="verify", prompt="Run deterministic prerequisites: test -d demo/rogue/original-rogue; test -f demo/rogue/original-rogue/rogue.h; command -v rustc; command -v cargo; command -v wasm-pack. Set outcome=success only if all checks pass. Use failure_class=deterministic for missing files/tools and failure_class=transient_infra for temporary execution/network failures."];
  check_toolchain [shape=diamond];

  expand_spec [shape=box, prompt="Task: Create or refresh canonical spec for $goal.\nRead: existing .ai/spec.md if present; repository context under demo/rogue/original-rogue/.\nWrite: .ai/spec.md and, if any critical unknowns remain, .ai/spec_gaps.md.\nAcceptance checks: .ai/spec.md defines exact mechanical-port constraints, ncurses-to-WASM bridge requirements, localStorage save/load, deliverable path demo/rogue/rogue-wasm/www/index.html, and concrete verification steps.\nVerbatim user input:\n<<<USER_INPUT\nPort the classic Rogue 5.4.4 game from C to Rust compiled to WebAssembly, playable in a browser. The original C source is at demo/rogue/original-rogue/ — about 16,800 lines across 33 files. The deliverable is a single HTML page at demo/rogue/rogue-wasm/www/index.html with classic ASCII terminal rendering: 80x24 grid, @ player, # corridors, monster letters A-Z, dark background, monospace font. This must be an exact mechanical port — same dungeon generation algorithms, same monster stats and AI, same item tables, same RNG formula, same combat math — a faithful 1:1 translation of every game system. ncurses I/O gets replaced by a WASM bridge to a JS terminal renderer, and save/load uses localStorage instead of the filesystem.\n<<<END_USER_INPUT\nOutcome behavior: set status=success only when .ai/spec.md is usable by downstream nodes; set status=retry only for transient infra blockers; set status=fail for deterministic blockers.\nStatus contract: Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write nested status.json files after cd. Use canonical schema {\"status\":\"success\"|\"retry\"|\"fail\"}. For status=fail or status=retry include failure_reason and details; include failure_class when deterministic blockers apply."];
  check_expand_spec [shape=diamond];

  define_dod [shape=box, prompt="Task: Produce project Definition of Done from .ai/spec.md.\nRead: .ai/spec.md and .ai/spec_gaps.md when present.\nWrite: .ai/definition_of_done.md and optional .ai/dod_gaps.md.\nAcceptance checks: DoD includes Scope, Deliverables, Acceptance Criteria, Verification, Quality/Safety Gates, and Non-Goals; explicitly covers build/package, tests, lint/format/static analysis, docs, compatibility/migrations, security/privacy, operational readiness, and performance/reliability with criteria or N/A rationale.\nOutcome behavior: set status=success only when the DoD is complete and testable; set status=retry only for transient infra blockers; set status=fail for deterministic blockers.\nStatus contract: Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write nested status.json files after cd. Use canonical schema {\"status\":\"success\"|\"retry\"|\"fail\"}. For status=fail or status=retry include failure_reason and details; include failure_class when deterministic blockers apply."];
  check_dod [shape=diamond];

  implement_port [shape=box, class="hard", prompt="Task: Implement an exact mechanical C-to-Rust port of Rogue 5.4.4 to WebAssembly.\nRead: .ai/spec.md, .ai/definition_of_done.md, and all source files under demo/rogue/original-rogue/.\nWrite: Rust/WASM implementation under demo/rogue/rogue-wasm/, browser entrypoint demo/rogue/rogue-wasm/www/index.html, JS terminal bridge replacing ncurses I/O, localStorage-backed save/load, seeded parity tests in demo/rogue/rogue-wasm/tests/parity_seeded_runs.rs, and .ai/implementation_log.md.\nAcceptance checks: preserve dungeon generation, RNG formula, monster stats/AI, item tables, combat math, and game-system behavior 1:1; UI renders 80x24 ASCII terminal with dark background and monospace styling.\nOutcome behavior: set status=success only when implementation and required artifacts are complete; set status=retry only for transient infra blockers; set status=fail for deterministic blockers.\nStatus contract: Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write nested status.json files after cd. Use canonical schema {\"status\":\"success\"|\"retry\"|\"fail\"}. For status=fail or status=retry include failure_reason and details; include failure_class when deterministic verification failures occur."];
  check_implement [shape=diamond];

  verify_build [shape=parallelogram, class="verify", prompt="Run deterministic verification commands in demo/rogue/rogue-wasm: cargo fmt --check; cargo clippy --all-targets -- -D warnings; cargo test; wasm-pack build --target web --release. Set outcome=success only if all pass. Use failure_class=deterministic for compile/test/lint failures and failure_class=transient_infra for temporary infrastructure failures."];
  check_build [shape=diamond];

  verify_deliverable [shape=parallelogram, class="verify", prompt="Run deterministic deliverable checks: test -f demo/rogue/rogue-wasm/www/index.html; grep -Eiq 'monospace' demo/rogue/rogue-wasm/www/index.html; grep -Eiq '80x24|cols[^0-9]*80|rows[^0-9]*24' demo/rogue/rogue-wasm/www/index.html; grep -Eiq 'background|dark' demo/rogue/rogue-wasm/www/index.html. Set failure_class=deterministic when any invariant is missing."];
  check_deliverable [shape=diamond];

  verify_parity [shape=parallelogram, class="verify", prompt="Run deterministic parity tests: cd demo/rogue/rogue-wasm && cargo test --test parity_seeded_runs -- --nocapture. The test must assert parity for RNG sequence, dungeon generation, monster stats/AI decisions, item tables, combat outcomes, and terminal glyph mapping for @, #, and monster letters A-Z. Use failure_class=deterministic for mismatches."];
  check_parity [shape=diamond];

  review_consensus [shape=box, class="review", goal_gate=true, prompt="Task: Decide whether $goal is complete per DoD.\nRead: .ai/spec.md, .ai/definition_of_done.md, .ai/implementation_log.md, and verification outcomes from prior nodes.\nWrite: .ai/review.md with evidence-based verdict and any remaining gaps.\nAcceptance checks: approve success only if DoD is met and mechanical parity requirements are evidenced; use partial_success only if core objective works with clearly bounded non-critical gaps; use retry/fail otherwise.\nOutcome behavior: set status=success when all DoD criteria are met; set status=partial_success only for bounded non-critical gaps; set status=retry for transient blockers; set status=fail for deterministic blockers.\nStatus contract: Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write nested status.json files after cd. Use canonical schema {\"status\":\"success\"|\"partial_success\"|\"retry\"|\"fail\"}. For status=fail or status=retry include failure_reason and details; include failure_class when deterministic blockers apply."];

  postmortem [shape=box, class="verify", prompt="Task: Analyze latest failure and produce a minimal, concrete repair plan for the next implementation attempt.\nRead: .ai/spec.md, .ai/definition_of_done.md, .ai/implementation_log.md, .ai/review.md if present, and failure context.\nWrite: .ai/postmortem.md with root cause, what changed assumptions, exact file-level fixes, and verification updates.\nAcceptance checks: plan is directly actionable, scoped, and addresses the failure_reason/details without broad rewrites.\nOutcome behavior: set status=success when an actionable repair plan is produced; set status=retry for transient blockers; set status=fail for deterministic blockers in analysis quality or missing evidence.\nStatus contract: Write status JSON to $KILROY_STAGE_STATUS_PATH (absolute path). If unavailable, use $KILROY_STAGE_STATUS_FALLBACK_PATH. Do not write nested status.json files after cd. Use canonical schema {\"status\":\"success\"|\"retry\"|\"fail\"}. For status=fail or status=retry include failure_reason and details; include failure_class when deterministic blockers apply."];
  check_postmortem [shape=diamond];

  start -> verify_toolchain;
  verify_toolchain -> check_toolchain;
  check_toolchain -> expand_spec [condition="outcome=success"];
  check_toolchain -> verify_toolchain [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true];
  check_toolchain -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"];
  check_toolchain -> postmortem;

  expand_spec -> check_expand_spec;
  check_expand_spec -> define_dod [condition="outcome=success"];
  check_expand_spec -> expand_spec [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true];
  check_expand_spec -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"];
  check_expand_spec -> postmortem;

  define_dod -> check_dod;
  check_dod -> implement_port [condition="outcome=success"];
  check_dod -> define_dod [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true];
  check_dod -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"];
  check_dod -> postmortem;

  implement_port -> check_implement;
  check_implement -> verify_build [condition="outcome=success"];
  check_implement -> implement_port [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true];
  check_implement -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"];
  check_implement -> postmortem;

  verify_build -> check_build;
  check_build -> verify_deliverable [condition="outcome=success"];
  check_build -> verify_build [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true];
  check_build -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"];
  check_build -> postmortem;

  verify_deliverable -> check_deliverable;
  check_deliverable -> verify_parity [condition="outcome=success"];
  check_deliverable -> verify_deliverable [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true];
  check_deliverable -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"];
  check_deliverable -> postmortem;

  verify_parity -> check_parity;
  check_parity -> review_consensus [condition="outcome=success"];
  check_parity -> verify_parity [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true];
  check_parity -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"];
  check_parity -> postmortem;

  review_consensus -> exit [condition="outcome=success"];
  review_consensus -> exit [condition="outcome=partial_success"];
  review_consensus -> postmortem [condition="outcome=retry"];
  review_consensus -> postmortem [condition="outcome=fail && context.failure_class!=transient_infra"];
  review_consensus -> postmortem [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true];
  review_consensus -> postmortem;

  postmortem -> check_postmortem;
  check_postmortem -> verify_toolchain [condition="outcome=success"];
  check_postmortem -> verify_toolchain [condition="outcome=retry"];
  check_postmortem -> postmortem [condition="outcome=fail && context.failure_class=transient_infra", loop_restart=true];
  check_postmortem -> verify_toolchain [condition="outcome=fail && context.failure_class!=transient_infra"];
  check_postmortem -> verify_toolchain;
}